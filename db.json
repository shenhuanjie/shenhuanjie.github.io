{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","path":"js/jquery-3.6.4.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1705675093941},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"4bf95d52f77edf811f23f6d264a7493311a8d078","modified":1705687635763},{"_id":"node_modules/hexo-theme-landscape/languages/de-DE.yml","hash":"d29d1c4256b7ed9df42f511c2ff0a23ad5fd6c1f","modified":1705687636008},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1705687634356},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":1705687636000},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1705687636012},{"_id":"node_modules/hexo-theme-landscape/languages/en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1705687636026},{"_id":"node_modules/hexo-theme-landscape/languages/en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1705687636022},{"_id":"node_modules/hexo-theme-landscape/languages/es-ES.yml","hash":"7008a8fc91f18d2a735864817b8ebda30c7a2c66","modified":1705687636035},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1705687636031},{"_id":"node_modules/hexo-theme-landscape/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1705687636015},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1705687636040},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"1a9b279e6dd29fd19245f913f0c4a316ffaa62db","modified":1705687635768},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1705687636077},{"_id":"node_modules/hexo-theme-landscape/languages/fr-FR.yml","hash":"8d09dbdab00a30a2870b56f7c0a7ca7deafa7b88","modified":1705687636043},{"_id":"node_modules/hexo-theme-landscape/languages/hu-HU.yml","hash":"712d18664898fa21ba38d4973e90ef41a324ea25","modified":1705687636082},{"_id":"node_modules/hexo-theme-landscape/languages/it-IT.yml","hash":"2cb6dc2fab9bd2dbe1c8bb869a9e8bf85a564fdd","modified":1705687636088},{"_id":"node_modules/hexo-theme-landscape/languages/ja-JP.yml","hash":"08481267e0c112e1f6855620f2837ec4c4a98bbd","modified":1705687636092},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1705687636094},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1705687636087},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1705687636098},{"_id":"node_modules/hexo-theme-landscape/languages/mn-MN.yml","hash":"b9e5f3e7c0c2f779cf2cfded6db847b5941637ca","modified":1705687636099},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1705687636101},{"_id":"node_modules/hexo-theme-landscape/languages/nl-NL.yml","hash":"5ebbc30021f05d99938f96dfff280392df7f91f0","modified":1705687636102},{"_id":"node_modules/hexo-theme-landscape/languages/ko-KR.yml","hash":"19209ad8f9d4057e8df808937f950eb265e1db69","modified":1705687636096},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1705687636090},{"_id":"node_modules/hexo-theme-landscape/languages/pt-PT.yml","hash":"0f852b6b228e6ea59aa3540574bb89b233f2a098","modified":1705687636107},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1705687636106},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1705687636104},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1705687636112},{"_id":"node_modules/hexo-theme-landscape/languages/th.yml","hash":"84a55b00aa01f03982be294e43c33a20e6d32862","modified":1705687636114},{"_id":"node_modules/hexo-theme-landscape/languages/th-TH.yml","hash":"ebfdba9bc4842c829473c1e6e4544344f182724d","modified":1705687636114},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1705687636110},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1705687636117},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1705687636117},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1705687635416},{"_id":"node_modules/hexo-theme-landscape/languages/ru-RU.yml","hash":"360d11a28bb768afb1dd15f63fa7fd3a8cc547ee","modified":1705687636111},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1705687635275},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1705687636119},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1705687635552},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1705687635652},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1705687635702},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1705687635603},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1705687635610},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1705687634966},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1705687635562},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1705687635051},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"377d257d5d16e0158a4405c72401517b074fd7ff","modified":1705687634824},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1705687635451},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"56597e951203dd662a6d2c817c7c4f1c920d4a25","modified":1705687635326},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1705687635482},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1705687635522},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1705687635574},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"6a5033d189554c9a6d42e2ef7952ae5c9742648e","modified":1705687635544},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1705687635626},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1705687635398},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1705687635199},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f05bced793b0314d4f2ef0c993b3a51d0b7d203a","modified":1705687635533},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1705687635658},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1705687635620},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1705687635777},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1705687635645},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"ca28281423ae57d76b6c1eb91cd845fd4e518bd6","modified":1705687635780},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"e55a1d92954ed20f6887f92dc727bb995a010a43","modified":1705687635992},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1705687634547},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1705687635352},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1705687635592},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1705687635759},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1705687635432},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1705687635638},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1705687635467},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1705687635666},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1705687635909},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"2d1f6f79ebf9cb55ebdb3865a2474437eb2b37c6","modified":1705687635904},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1705687635788},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1705687635914},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"268d2989acb06e2ddd06cc36a6918c6cd865476b","modified":1705687635934},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"9cc3b2927d814f2f6e8e188f9d3657b94f4c6ef3","modified":1705687635939},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1705687635970},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1705687635978},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1705687635973},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1705687635983},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1705687635930},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1705687635752},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1705687635737},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1705687635967},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1705687635697},{"_id":"public/2024/01/20/hello-world/index.html","hash":"84044f9e75a7a7f341de287cdfc09c194dbe13aa","modified":1705687684954},{"_id":"public/index.html","hash":"4d86b77d33c2cd6c58deb6408c3bc40bbf75105e","modified":1705687684954},{"_id":"public/archives/index.html","hash":"3f4d9c90c28531e83452bba35181d3a8d9bd94fa","modified":1705687684954},{"_id":"public/archives/2024/index.html","hash":"67b4893f1b3e69099cf071338404636d42c9b0ad","modified":1705687684954},{"_id":"public/archives/2024/01/index.html","hash":"fad3e4dbb896890c7a07d410d8d8e435f1c88ce9","modified":1705687684954},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1705687684954},{"_id":"public/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1705687684954},{"_id":"public/css/style.css","hash":"ddb3792605d744ab3d9f0a649c82b62e9b16daa6","modified":1705687684954},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1705687684954},{"_id":"public/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1705687684954},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1705687684954},{"_id":"source/_posts/full-annotated-spring-ioc.md","hash":"34cdbb161ce44d53684d71b2647e57423e629e08","modified":1705691052980}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2024-01-19T18:07:07.354Z","updated":"2024-01-19T14:38:13.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrkyer1800009ouy40d2br1i","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"全注解下的 Spring IoC","date":"2024-01-19T19:02:30.000Z","_content":"\n# 第 3 章 全注解下的 Spring IoC\n本章先探讨 Spring 的控制反转（IoC）的应用。Spring 最成功的是其提出的理念，而不是技术本身。它所依赖的两个核心概念，一个是控制反转（Inversion of Controller，IoC）另一个是面向切面编程（Aspect Oriented Programming，AOP）。IoC 容器是 Spring 的核心，可以说 Spring 是一种基于 IoC 容器编程的框架。因为 Spring Boot 是基于注解的开发 Spring IoC，所以我们使用全注解的方式讲述 Spring IoC 技术，为后续章节打下基础。\n\nIoC 是一种通过描述来生成或者获取对象的技术，而这个技术不是 Spring 甚至不是 Java 独有的。对于 Java 的初学者更多的时候所熟悉的是使用 new 关键字来创建对象，而在 Spring 中则不是，它是通过描述来创建对象。只是 Spring Boot 并不建议使用 XML，而是通过注解的描述生成对象，所以本章主要是通过注解来介绍 Spring IoC 技术。\n\n一个系统可以生成各种对象，并且这些对象都需要进行管理。还值得一提的是，对象之间并不是孤立的，它们之间还可能存在依赖的关系。例如，一个班级是由多个老师和同学组成的，那么班级就依赖于多个老师和同学了。为此 Spring 还提供了依赖注入的功能，使得我们能够通过描述来管理各个对象之间的关系。\n\n为了描述上述的班级、同学和老师这 3 个对象关系，我们需要一个容器。在 Spring 中把每一个需要管理的对象称为 Spring Bean（简称 Bean），而 Spring 管理这些 Bean 的容器，被我们称为 Spring IoC 容器（或者简称 IoC 容器）。IoC 容器需要具备两个基本的功能：\n\n* 通过描述管理 Bean，包括发布和获取 Bean；\n* 通过描述完成 Bean 之间的依赖关系。\n\n在使用 IoC 之前，需要对 Spring IoC 容器有一个基本的认识。\n\n## 3.1 IoC 容器简介\nSpring IoC 容器是一个管理 Bean 的容器，在 Spring 的定义中，它要求所有的 IoC 容器都需要实现接口 BeanFactory，它是一个顶级容器接口。为了增加对它的理解，我们首先阅读其源码，并讨论几个重要的方法。接口源码如代码清单 3-1 所示。\n\n```java\npackage org.springframework.beans.factory;\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.core.ResolvableType;\n\npublic interface BeanFactory {\n    // 前缀\n    String FACTORY_BEAN_PREFIX = \"&\";\n\n    // 多个 getBean 方法\n    Object getBean(String name) throws BeansException;\n\n    <T> T getBean(String name, Class<T> requiredType) throws BeansException;\n\n    <T> T getBean(Class<T> requiredType) throws BeansException;\n\n    Object getBean(String name, Object... args) throws BeansException;\n\n    <T> T getBean(Class<T> requiredType, Object... args) throws BeansException;\n\n    // 是否包含 Bean\n    boolean containsBean(String name);\n\n    // Bean 是否是单例\n    boolean isSingleton(String name) throws NoSuchBeanDefinitionException;\n\n    // Bean 是否是原型\n    boolean isPrototype(String name) throws NoSuchBeanDefinitionException;\n\n    // 是否类型匹配\n    boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;\n\n    boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException;\n\n    // 获取 Bean 的类型\n    Class<?> getType(String name) throws NoSuchBeanDefinitionException;\n\n    // 获取 Bean 的别名\n    String[] getAliases(String name);\n}\n```\n这段代码中加入了中文注释，通过它们就可以理解这些方法的含义。这里值得注意的是接口中的几个方法。首先我们看到了多个 getBean 方法，这也是 IoC 容器最重要的方法之一，它的意义是从 IoC 容器中获取 Bean。而从多个 getBean 方法中可以看到有按类型（by type）获取 Bean 的，也有按名称（by name）获取 Bean 的，这就意味着在 Spring IoC 容器中，允许我们按类型或者名称获取 Bean，这对理解后面将讲到的 Spring 的依赖注入（Dependency Injection，DI）是十分重要的。\n\nisSingleton 方法则判断 Bean 是否在 Spring IoC 中为单例。这里需要记住是在 Spring IoC 容器中，默认的情况下，Bean 都是以单例存在的。也就是使用 getBean 方法返回的都是同一个对象。与 isSingleton 方法相反的时 isPrototype 方法，如果它返回的是 true，那么当我们使用 getBean 方法获取 Bean 的时候，Spring IoC 容器就会创建一个新的 Bean 返回给调用者，这些与后面将讨论的 Bean 作用于相关。\n\n由于 BeanFactory 的功能还不够强大，因此 Spring 在 BeanFactory 的基础上，还设计了一个更为高级的接口 ApplicationContext。它是 BeanFactory 的子接口之一，在 Spring 的体系中 BeanFactory 和 ApplicationContext 是最为重要的接口设计，在现实中我们使用的大部分 Spring IoC 容器是 ApplicationContext 接口的实现类，它们的关系如图 3-1 所示。\n\n![image](images/uhw4BvOe-bbHfhH2O3USvEAbPYHU9BBByUD2gN1W614.png)\n\n在图中可以看到，ApplicationContext 接口通过继承上级接口，进而继承 BeanFactory 接口，但是在 BeanFactory 的基础上，扩展了消息国际化接口（MessageSource）、环境可配置接口（EnvironmentCapable）、应用事件发布接口（ApplicationEventPublisher）和资源模式解析接口（ResourcePatternResolver），所以它的功能会更为强大。\n\n在 Spring Boot 当中我们主要是通过注解来装配 Bean 到 Spring IoC 容器中，为了贴近 Spring Boot 的需要，这里不再介绍与 XML 相关的 IoC 容器，而主要介绍一个基于注解的 IoC 容器，它就是 AnnotationConfigApplicationContext，从名称就可以看出它是一个基于注解的 IoC 容器。之所以研究它，是因为Spring Boot 装配和获取 Bean 的方法与它如出一辙。\n\n下面来看一个最为简单的例子。首先定义一个 Java简单对象（Plain Ordinary Java Object，POJO）文件 User.java，如代码清单 3-2 所示。\n\n```java\npackage com.springboot.chapter3.pojo;\n\npublic class User {\n    private Long id;\n    private String userName;\n    private String note;\n\n    // 省略setter和getter方法\n}\n```\n然后再定义一个 Java 配置文件 AppConfig.java，如代码清单 3-3 所示。\n\n```java\npackage com.springboot.chapter3.config;\n\nimport com.springboot.chapter3.pojo.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AppConfig {\n    @Bean(name = \"user\")\n    public User initUser() {\n        User user = new User();\n        user.setId(1L);\n        user.setUserName(\"user_name_1\");\n        user.setNote(\"note_1\");\n        return user;\n    }\n}\n```\n这里需要注意加粗的注解。@Configuration 代表这是一个 Java 配置文件，Spring 的容器会根据它来生成 IoC 容器去装配 Bean：@Bean 代表将 initUser 方法返回的 POJO 装配到 IoC 容器中，而其属性 name 定义这个 Bean 的名称，如果没有配置它，则将方法名称“initUser”作为 Bean 的名称保存到 Spring IoC 容器中。\n\n做好了这些，就可以使用 AnnotationConfigApplicationContext 来构建自己的 IoC 容器，如代码清单 3-4 所示。\n\n```java\npackage com.springboot.chapter3.config;\n\n\nimport com.springboot.chapter3.pojo.User;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\nimport java.util.logging.Logger;\n\n\npublic class IoCTest {\n    private static final Logger log = Logger.getLogger(IoCTest.class.getName());\n\n    public static void main(String[] args) {\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n        User user = ctx.getBean(User.class);\n        log.info(user.getId().toString());\n    }\n}\n\n```\n代码中将 Java 配置文件 AppConfig 传递给 AnnotationConfigApplicationContext 的构造方法，这样它就能够读取配置了。然后将配置里面的 Bean 装配到 IoC 容器中，于是可以使用 getBean 方法获取对应的 POJO，你可以看到下面的日志打印：\n\n![image](images/W0ntjjclR0cRfx9d2qlynjZFvQ1yu8nfw6qDzTiIKMY.png)\n\n显然，配置在配置文件中的名称为 user 的 Bean 已经被装配到 IoC 容器中，并且可以通过getBean 方法获取对应的 Bean，并建 Bean 的属性信息输出出来。当然这只是很简单的方法，而注解 @Bean 也不是唯一创建 Bean 的方法，还有其他的方法可以让 IoC 容器装配 Bean，而且 Bean 之间还有依赖的关系需要进一步处理。这是本章后面章节的主要内容了。\n\n## 3.2 装配你的 Bean\n在 Spring 中允许我们通过 XML 或者 Java 配置文件装配 Bean，但是由于 Spring Boot 是基于注解的方式，因此下面主要基于注解的方式来介绍 Spring 的用啊，以满足 Spring Boot 开发者的需要。\n\n### 3.2.1 通过扫描装配你的 Bean\n如果一个个的 Bean 使用注解 @Bean 注入 Spring IoC 容器中，那将是一件很麻烦的事情。好在 Spring 还允许我们进行扫描装配 Bean 到 IoC 容器中，对于扫描装配而言使用的注解是 @Component 和 @ComponentScan。@Component 是标明哪个类被扫描进入 Spring IoC 容器，而 @ComponentScan 则是标明采用何种策略去扫描装配到 Bean。\n\n这里我们首先把代码清单 3-2 中的 User.java 移到包 com.springboot.chapter3.config 内，然后对其进行修改，如代码清单 3-5 所示。\n\n```java\npackage com.springboot.chapter3.config;\n\nimport lombok.Data;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component(\"user\")\n@Data\npublic class User {\n    @Value(\"1\")\n    private Long id;\n    @Value(\"user_name_1\")\n    private String userName;\n    @Value(\"note_1\")\n    private String note;\n\n    // setter and getter\n}\n\n```\n这里的注解 @Component 表明这个类将被 Spring IoC 容器扫描装配，其中配置的“user”则是作为 Bean 的名称，当然你也可以不配置这个字符串，那么 IoC 容器就会把类名第一个字母作为小写，其他不变作为 Bean 名称放入到 IoC 容器中；注解 @Value 则是指定具体的值，使得 Spring IoC 给于对应的属性注入对应的值。为了让 Spring IoC 容器装配这个类，需要改造类 AppConfig，如代码清单 3-6 所示。\n\n```java\npackage com.springboot.chapter3.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@ComponentScan\npublic class AppConfig {\n}\n\n```\n这里加入了 @ComponentScan，意味着它会进行扫描，但是它只会扫描类 AppConfig 所在的当前包和其子包，之前把 User.java 移到包 com.springboot.chapter3.config 就是这样原因。这样就可以删掉之前使用 @Bean 标注的创建对象方法。然后进行测试，测试代码如代码清单 3-7 所示。\n\n```java\npackage com.springboot.chapter3.config;\n\n\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\nimport java.util.logging.Logger;\n\n\npublic class IoCTest {\n    private static final Logger log = Logger.getLogger(IoCTest.class.getName());\n\n    public static void main(String[] args) {\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n        User user = ctx.getBean(User.class);\n        log.info(user.getId().toString());\n    }\n}\n\n```\n这样就能够运行了。然而为了使得 User类能够被扫描，上面我们把它迁移到了本不该放置它的配置包，这样显然就不太合理了。为了更加合理，@ComponentScan 还允许我们自定义扫描的包。下面探讨它的配置项。\n\n首先探讨 @ComponentScan 的源码，如代码清单 3-8 所示。\n\n```java\npackage org.springframework.context.annotation;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Documented\n// 在一个类中可重复定义\n@Repeatable(ComponentScans.class)\npublic @interface ComponentScan {\n\n    // 定义扫描的包\n    @AliasFor(\"basePackages\")\n    String[] value() default {};\n\n    // 定义扫描的包\n    @AliasFor(\"value\")\n    String[] basePackages() default {};\n\n    // 定义扫描的类\n    Class<?>[] basePackageClasses() default {};\n\n    // Bean name 生成器\n    Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;\n\n    // 作用域解析器\n    Class<? extends ScopeMetadataResolver> scopeResolver() default AnnotationScopeMetadataResolver.class;\n\n    // 作用域代理模式\n    ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;\n\n    // 资源匹配模式\n    String resourcePattern() default ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;\n\n    // 是否启用默认的过滤器\n    boolean useDefaultFilters() default true;\n\n    // 当满足过滤器的条件时扫描\n    Filter[] includeFilters() default {};\n\n    // 当不满足过滤器的条件时扫描\n    Filter[] excludeFilters() default {};\n\n    // 是否延迟初始化\n    boolean lazyInit() default false;\n\n    // 定义过滤器\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target({})\n    @interface Filter {\n\n        // 过滤器类型，可以按注解类型或者正则式等过滤\n        FilterType type() default FilterType.ANNOTATION;\n\n        // 定义过滤的类\n        @AliasFor(\"classes\")\n        Class<?>[] value() default {};\n\n        // 定义过滤的类\n        @AliasFor(\"value\")\n        Class<?>[] classes() default {};\n\n        // 匹配方式\n        String[] pattern() default {};\n\n    }\n}\n```\n上面加粗的代码是最常用的配置项，需要了解它们的使用方法。首先可以通过配置项 basePackages 定义扫描的包名，在没有定义的情况下，它只会扫描当前包和其子包下的路径；还可以通过 basePackageClasses 定义扫描的类；其中还有 includeFilters 和 excludeFilters，includeFilters 是定义满足过滤器（Filter）条件的 Bean 才去扫描，excludeFilters 则是排除过滤器条件的 Bean，它们都需要通过一个注解 @Filter 去定义，它有一个type 类型，这里可以定义为注解或者正则式等类型。classes 定义注解类，pattern 定义正则式类。\n\n此时我们再把 User 类放到包 com.springboot.chapter3.pojo 中，这样 User 和 AppConfig 就不再同包，那么我们把 AppConfig 中的注解修改为：\n\n```java\n@ComponentScan(\"com.springboot.chapter3.*\")\n```\n或\n\n```java\n@ComponentScan(basePackages = {\"com.springboot.chapter3.pojo\"})\n```\n或\n\n```java\n@ComponentScan(basePackageClasses = {User.class})\n```\n无论采用何种方式都能够使得 IoC 容器去扫描 User 类，而包名可以采用正则去匹配。但是有时候我们的需求是想扫描一些包，将一些 Bean 装配到 Spring IoC 容器中，而不是想加载这个包里面的某些 Bean。比方说，现在我们有一个 UserService 类，为了标注它为服务类，将类标注 @Service（该标准注入了 @Component，所以在默认的情况下它会被 Spring 扫描装配到 IoC 容器中），这里再假设我们采用了策略：\n\n```java\n@ComponentScan(\"com.springboot.chapter3.*\")\n```\n这样对于 com.springboot.chapter3.service 和 com.springboot.chapter3.pojo，这两个包都会被扫描，此时我们定义 UserService 类如代码清单 3-9 所示。\n\n```java\npackage com.springboot.chapter3.service;\n\nimport com.springboot.chapter3.pojo.User;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserService {\n\n    public void printUser(User user) {\n        System.out.println(\"编号：\" + user.getId());\n        System.out.println(\"用户名称：\" + user.getUserName());\n        System.out.println(\"备注：\" + user.getNote());\n    }\n}\n```\n按以上的装配策略，它将会被扫描到 Spring IoC 容器中。为了不被装配，需要把扫描的策略修改为：\n\n```java\n@ComponentScan(value = \"com.springboot.chapter3.*\", excludeFilters = {@ComponentScan.Filter(classes = {Provider.Service.class})})\n```\n这样，由于加入了 excludeFilters 的配置，使标注了@Service 的类将不被 IoC 容器扫描注入，这样就可以把 UserService 类排除到 Spring IoC 容器中了。事实上，之前在 Spring Boot 上述实例中看到的注解@SpringBootApplication 也注入了@ComponentScan，这里不妨探索其源码，如代码清单 3-10 所示。\n\n```java\npackage org.springframework.boot.autoconfigure;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.TYPE)\n@Retention(java.lang.annotation.RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootApplication\n@EnableAutoConfiguration\n// 自定义排除的扫描类\n@ComponentScan(excludeFilters = {\n        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n\n    // 通过类型排除自动配置类\n    @AliasFor(annotation = EnableAutoConfiguration.class, attribute = \"exclude\")\n    Class<?>[] exclude() default {};\n\n    // 通过名称排除自动配置类\n    @AliasFor(annotation = EnableAutoConfiguration.class, attribute = \"excludeName\")\n    String[] excludeName() default {};\n\n    // 定义扫描的包\n    @AliasFor(annotation = ComponentScan.class, attribute = \"basePackages\")\n    String[] scanBasePackages() default {};\n\n    // 定义扫描的类\n    @AliasFor(annotation = ComponentScan.class, attribute = \"basePackageClasses\")\n    Class<?>[] scanBasePackageClasses() default {};\n}\n```\n显然，通过它就能够定义扫描哪些包。但是这里需要特别注意的是，它提供的 exclude 和 excludeName 两个方法是对于其内部的自动配置类才会生效的。为了能够排除其他类，还可以再加入@ComponentScan以达到我们的目的。例如，扫描 User 而不扫描 UserService，可以把启动配置文件写成：\n\n```java\n@SpringBootApplication\n@ComponentScan(basePackage = {\"com.springboot.chapter3\"},excludeFilters = {@Filter{classes = Service.class})\n```\n这样就能扫描指定对应的包并排除对应的类了。\n\n### 3.2.2 自定义第三方 Bean\n现实的 Java 的应用往往需要引入许多来自第三方的包，并且很有可能希望把第三方包的类对象也放入到 Spring IoC 容器中，这时@Bean 注解就可以发挥作用了。\n\n例如，要引入一个 DBCP 数据源，我们先在 pom.xml上加入项目所需要 DBCP 包和数据库 MySQL 驱动程序的依赖，如代码清单 3-11 所示。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.springboot</groupId>\n    <artifactId>chapter3</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>chapter3</name>\n    <description>chapter3</description>\n    <properties>\n        <java.version>8</java.version>\n    </properties>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>6.0.10</version>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>1.18.26</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.commons</groupId>\n            <artifactId>commons-dbcp2</artifactId>\n            <version>2.9.0</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>8.0.33</version>\n        </dependency>\n    </dependencies>\n\n</project>\n\n```\n这样 DBCP 和数据库驱动就被加入到了项目中，接着将使用它提供的机制来生成数据源。这时候，可以把代码清单 3-12 中的代码放置到 AppConfig.java 中。\n\n```java\npackage com.springboot.chapter3.config;\n\nimport org.apache.commons.dbcp2.BasicDataSourceFactory;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\nimport javax.sql.DataSource;\nimport java.security.Provider;\nimport java.util.Properties;\n\n@Configuration\n@ComponentScan(value = \"com.springboot.chapter3.*\", excludeFilters = {@ComponentScan.Filter(classes = {Provider.Service.class})})\npublic class AppConfig {\n    @Bean(name = \"dataSource\")\n    public DataSource getDataSource() {\n        Properties props = new Properties();\n        props.setProperty(\"driver\", \"com.mysql.jdbc.Driver\");\n        props.setProperty(\"url\", \"jdbc:mysql://localhost:3306/chapter3\");\n        props.setProperty(\"username\", \"root\");\n        props.setProperty(\"password\", \"123456\");\n        DataSource dataSource = null;\n        try {\n            dataSource = BasicDataSourceFactory.createDataSource(props);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return dataSource;\n    }\n}\n\n```\n这里通过 @Bean 定义了其配置项 name 为“dataSource”，那么 Spring 就会把它返回的对象用名称“dataSource”保存到 IoC 容器中。当然，你也可以不填写这个名称，那么它就会用你的方法名称作为 Bean 名称保存到 IoC 容器中。通过这样，就可以将第三方包的类装配到 Spring IoC 容器中了。\n\n## 3.3 依赖注入\n本章的开始讲述了 Spring IoC 的两个作用，上一节只讨论了如何将 Bean 装配到 IoC 容器中，对于如何进行获取，还有一个作用没有谈及，那就是 Bean 之间的依赖，在 Spring IoC 的概念中，我们称为依赖注入（Dependency Injection，DI）。\n\n例如，人类（Person）有时候利用一些动物（Animal）去完成一些事情，比方说狗（Dog）是用来看门的，猫（Cat）是用来抓老鼠的，鹦鹉（Parrot）是用来迎客的……于是做一些事情就依赖于那些可爱的动物了，如图 3-2 所示。\n\n为了更好地展示这个过程，首先来定义两个接口，一个是人类（Person），另一个是动物（Animal）。人类是通过动物去提供一些特殊服务的，如代码清单 3-13 所示。\n\n```java\npackage com.springboot.chapter3.pojo.definition;\n\npublic interface Person {\n\n    // 使用动物服务\n    void service();\n\n    // 设置动物\n    void setAnimal(Animal animal);\n}\n```\n```java\npackage com.springboot.chapter3.pojo.definition;\n\npublic interface Animal {\n    void use();\n}\n```\n这样我们就拥有了两个接口。接下来我们需要两个实现类，如代码亲的那 3-14 所示。\n\n```java\npackage com.springboot.chapter3.pojo;\n\nimport com.springboot.chapter3.pojo.definition.Animal;\nimport com.springboot.chapter3.pojo.definition.Person;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class BusinessPerson implements Person {\n\n    @Autowired\n    private Animal animal = null;\n\n    @Override\n    public void service() {\n        this.animal.use();\n    }\n\n    @Override\n    public void setAnimal(Animal animal) {\n        this.animal = animal;\n    }\n}\n```\n```java\npackage com.springboot.chapter3.pojo;\n\nimport com.springboot.chapter3.pojo.definition.Animal;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class Dog implements Animal {\n    @Override\n    public void use() {\n        System.out.println(\"狗【\" + Dog.class.getSimpleName() + \"】是看门用的。\");\n    }\n}\n```\n这里应注意加粗的注解 @Autowired，这也是我们在 Spring 中最常用的注解之一，十分重要，它会根据属性的类型（by type）找到对应的 Bean 进行注入。这里的 Dog 类是动物的一种，所以 Spring IoC 容器会把 Dog 的实例注入 BusinessPerson 中。这样通过 Spring IoC 容器获取 BusinessPerson 实例的时候就能够使用 Dog 实例来提供服务了，下面是测试的代码。\n\n```java\npackage com.springboot.chapter3.config;\n\n\nimport com.springboot.chapter3.pojo.BusinessPerson;\nimport com.springboot.chapter3.pojo.definition.Person;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\nimport java.util.logging.Logger;\n\n\npublic class IoCTest {\n    private static final Logger log = Logger.getLogger(IoCTest.class.getName());\n\n    public static void main(String[] args) {\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n        Person person = ctx.getBean(BusinessPerson.class);\n        person.service();\n    }\n}\n```\n测试一下，就可以得到下面的日志：\n\n```bash\n狗【Dog】是看门用的。\n```\n显然，测试是成功的，这个时候 Spring IoC 容器已经通过注解 @Autowired 成功地将 Dog 注入到了 BusinessPerson 实例中。但是这只是一个比较简单的例子，我们有必要继续探讨 @Autowired。\n\n### 3.3.1 注解@Autowired\n@Autowired 是我们使用得最多的注解之一，因此在这里需要进一步地探讨它。它注入的机制最基本的一条是根据类型（by type），我们回顾 IoC 容器的顶级接口 BeanFactory，就可以知道 IoC 容器是通过 getBean 方法获取对应 Bean 的，而 getBean 又支持根据类型（by type）或者根据名称（by name）。在回到上面的例子，我们只是创建了一个动物——狗，而实际上动物还可以有猫（Cat），猫可以为我们捉老鼠，于是我们又创建了一个猫的类，如代码清单 3-15 所示。\n\n```java\npackage com.springboot.chapter3.pojo;\n\nimport com.springboot.chapter3.pojo.definition.Animal;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class Cat implements Animal {\n    @Override\n    public void use() {\n        System.out.println(\"猫【\" + Cat.class.getSimpleName() + \"】是抓老鼠。\");\n    }\n}\n\n```\n好了，如果我们还使用着代码清单 3-14 中的 BusinessPerson 类，那么麻烦来了，因为这个类只是定义了一个动物属性（Animal），而我们却有两个动物，一个狗，一个猫，Spring IoC 如何注入呢？如果你还进行测试，很快你就可以看到 IoC 容器抛出异常，如下面的日志所示：\n\n```bash\n警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'businessPerson': Unsatisfied dependency expressed through field 'animal': No qualifying bean of type 'com.springboot.chapter3.pojo.definition.Animal' available: expected single matching bean but found 2: cat,dog\n```\n从加粗的日志可以看出，Spring IoC 容器并不能知道你需要注入什么动物（是狗？是猫？）给 BusinessPerson 类对象，从而引起错误的发生。那么使用@Autowired 能处理这个问题吗？答案是肯定的。假设我们目前需要的是狗提供服务，那么可以把属性名称转化为 dog，也就是原来的\n\n```java\n    @Autowired\n    private Animal animal = null;\n```\n修改为\n\n```java\n    @Autowired\n    private Animal dog = null;\n```\n这里，我们只是将属性的名称从 animal 修改为了 dog，那么我们再测试的时候，你可以看到是采用狗来提供服务的。那是因为 @Autowired 提供这样的规则，首先它会根据类型找到对应的 Bean，如果对应类型的 Bean 不是唯一的，那么它会根据其属性名称和 Bean 的名称进行匹配。如果匹配得上，就会使用该 Bean；如果还无法匹配，就会抛出异常。\n\n这里还要注意的是 @Autowired 是一个默认必须找到对应 Bean 的注解，如果不能确定其标注属性一定会存在并且允许这个被标注的属性为 null，那么你可以配置 @Autowired 属性 required 为 false，例如，像下面一样：\n\n```java\n    @Autowired(required = false)\n```\n同样，它除了可以标注属性外，还可以标注方法，如 setAnimal 方法，如下所示：\n\n```java\n@Override\n@Autowired\npublic void setAnimal (Animal animal) {\n    this.animal = animal;\n}\n```\n这样它也会使用 setAnimal 方法从 IoC 容器中找到对应的动物进行注入，甚至我们还可以使用在方法参数上，后面会再谈到它。\n\n### 3.3.2 消除歧义性——@Primary 和 @Quelifier\n在上面我们发现有猫有狗的时候，为了使@Autowired 能够继续使用，我们做了一个决定，将 BusinessPerson 的属性名称从 animal 修改为 dog。显然这是一个憋屈的做法，好好的一个动物，却被我们定义为了狗。产生注入失败的问题根本是按类型（by type）查找，正如动物可以有多种类型，这样会造成 Spring IoC 容器注入的困扰，我们把这样的一个问题称为歧义性。知道这个原因后，那么这两个注解是从哪个角度去解决这些问题的呢？这是本节要解决的问题。\n\n首先是一个注解 @Primary，它是一个修改优先权的注解，当我们有猫有狗的时候，假设这次需要使用猫，那么只需要在猫类的定义上加入@Primary 就可以了，类似下面这样：\n\n```java\npackage com.springboot.chapter3.pojo;\n\nimport com.springboot.chapter3.pojo.definition.Animal;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.stereotype.Component;\n\n@Component\n@Primary\npublic class Cat implements Animal {\n    @Override\n    public void use() {\n        System.out.println(\"猫【\" + Cat.class.getSimpleName() + \"】是抓老鼠。\");\n    }\n}\n```\n这里的 @Primary 的含义告诉 Spring IoC 容器，当发现有多个同样类型的 Bean 时，请优先使用我进行注入，于是再进行测试时会发现，系统将用猫 为你提供服务。因为当 Spring 进行注入的时候，虽然它发现存在多个动物，但因为 Cat 被标注为了 @Primary，所以优先采用 Cat 的实例进行了注入，这样就通过优先级的变换使得 IoC 容器知道注入哪个具体的实例来满足依赖注入。\n\n\n\n### 3.3.3 带有参数的构造方法类的装配\n## 3.4 生命周期\n## 3.5 使用属性文件\n## 3.6 条件装配 Bean\n## 3.7 Bean 的作用域\n## 3.8 使用@Profile\n## 3.9 引入 XML 配置 Bean\n## 3.10 使用 Spring EL","source":"_posts/full-annotated-spring-ioc.md","raw":"---\ntitle: 全注解下的 Spring IoC\ndate: 2024-01-20 03:02:30\ntags: spring, ioc, spring ioc, spring bean, spring bean definition, spring bean factory, spring bean container, spring bean post processor, spring bean pre processor, spring bean definition reader, spring bean definition parser, spring bean definition registry, spring bean definition factory, spring bean definition factory bean, spring bean definition factory bean post processor, spring bean definition factory bean pre processor, spring bean definition factory bean parser, spring bean definition factory bean registry, spring bean definition factory bean factory\n---\n\n# 第 3 章 全注解下的 Spring IoC\n本章先探讨 Spring 的控制反转（IoC）的应用。Spring 最成功的是其提出的理念，而不是技术本身。它所依赖的两个核心概念，一个是控制反转（Inversion of Controller，IoC）另一个是面向切面编程（Aspect Oriented Programming，AOP）。IoC 容器是 Spring 的核心，可以说 Spring 是一种基于 IoC 容器编程的框架。因为 Spring Boot 是基于注解的开发 Spring IoC，所以我们使用全注解的方式讲述 Spring IoC 技术，为后续章节打下基础。\n\nIoC 是一种通过描述来生成或者获取对象的技术，而这个技术不是 Spring 甚至不是 Java 独有的。对于 Java 的初学者更多的时候所熟悉的是使用 new 关键字来创建对象，而在 Spring 中则不是，它是通过描述来创建对象。只是 Spring Boot 并不建议使用 XML，而是通过注解的描述生成对象，所以本章主要是通过注解来介绍 Spring IoC 技术。\n\n一个系统可以生成各种对象，并且这些对象都需要进行管理。还值得一提的是，对象之间并不是孤立的，它们之间还可能存在依赖的关系。例如，一个班级是由多个老师和同学组成的，那么班级就依赖于多个老师和同学了。为此 Spring 还提供了依赖注入的功能，使得我们能够通过描述来管理各个对象之间的关系。\n\n为了描述上述的班级、同学和老师这 3 个对象关系，我们需要一个容器。在 Spring 中把每一个需要管理的对象称为 Spring Bean（简称 Bean），而 Spring 管理这些 Bean 的容器，被我们称为 Spring IoC 容器（或者简称 IoC 容器）。IoC 容器需要具备两个基本的功能：\n\n* 通过描述管理 Bean，包括发布和获取 Bean；\n* 通过描述完成 Bean 之间的依赖关系。\n\n在使用 IoC 之前，需要对 Spring IoC 容器有一个基本的认识。\n\n## 3.1 IoC 容器简介\nSpring IoC 容器是一个管理 Bean 的容器，在 Spring 的定义中，它要求所有的 IoC 容器都需要实现接口 BeanFactory，它是一个顶级容器接口。为了增加对它的理解，我们首先阅读其源码，并讨论几个重要的方法。接口源码如代码清单 3-1 所示。\n\n```java\npackage org.springframework.beans.factory;\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.core.ResolvableType;\n\npublic interface BeanFactory {\n    // 前缀\n    String FACTORY_BEAN_PREFIX = \"&\";\n\n    // 多个 getBean 方法\n    Object getBean(String name) throws BeansException;\n\n    <T> T getBean(String name, Class<T> requiredType) throws BeansException;\n\n    <T> T getBean(Class<T> requiredType) throws BeansException;\n\n    Object getBean(String name, Object... args) throws BeansException;\n\n    <T> T getBean(Class<T> requiredType, Object... args) throws BeansException;\n\n    // 是否包含 Bean\n    boolean containsBean(String name);\n\n    // Bean 是否是单例\n    boolean isSingleton(String name) throws NoSuchBeanDefinitionException;\n\n    // Bean 是否是原型\n    boolean isPrototype(String name) throws NoSuchBeanDefinitionException;\n\n    // 是否类型匹配\n    boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;\n\n    boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException;\n\n    // 获取 Bean 的类型\n    Class<?> getType(String name) throws NoSuchBeanDefinitionException;\n\n    // 获取 Bean 的别名\n    String[] getAliases(String name);\n}\n```\n这段代码中加入了中文注释，通过它们就可以理解这些方法的含义。这里值得注意的是接口中的几个方法。首先我们看到了多个 getBean 方法，这也是 IoC 容器最重要的方法之一，它的意义是从 IoC 容器中获取 Bean。而从多个 getBean 方法中可以看到有按类型（by type）获取 Bean 的，也有按名称（by name）获取 Bean 的，这就意味着在 Spring IoC 容器中，允许我们按类型或者名称获取 Bean，这对理解后面将讲到的 Spring 的依赖注入（Dependency Injection，DI）是十分重要的。\n\nisSingleton 方法则判断 Bean 是否在 Spring IoC 中为单例。这里需要记住是在 Spring IoC 容器中，默认的情况下，Bean 都是以单例存在的。也就是使用 getBean 方法返回的都是同一个对象。与 isSingleton 方法相反的时 isPrototype 方法，如果它返回的是 true，那么当我们使用 getBean 方法获取 Bean 的时候，Spring IoC 容器就会创建一个新的 Bean 返回给调用者，这些与后面将讨论的 Bean 作用于相关。\n\n由于 BeanFactory 的功能还不够强大，因此 Spring 在 BeanFactory 的基础上，还设计了一个更为高级的接口 ApplicationContext。它是 BeanFactory 的子接口之一，在 Spring 的体系中 BeanFactory 和 ApplicationContext 是最为重要的接口设计，在现实中我们使用的大部分 Spring IoC 容器是 ApplicationContext 接口的实现类，它们的关系如图 3-1 所示。\n\n![image](images/uhw4BvOe-bbHfhH2O3USvEAbPYHU9BBByUD2gN1W614.png)\n\n在图中可以看到，ApplicationContext 接口通过继承上级接口，进而继承 BeanFactory 接口，但是在 BeanFactory 的基础上，扩展了消息国际化接口（MessageSource）、环境可配置接口（EnvironmentCapable）、应用事件发布接口（ApplicationEventPublisher）和资源模式解析接口（ResourcePatternResolver），所以它的功能会更为强大。\n\n在 Spring Boot 当中我们主要是通过注解来装配 Bean 到 Spring IoC 容器中，为了贴近 Spring Boot 的需要，这里不再介绍与 XML 相关的 IoC 容器，而主要介绍一个基于注解的 IoC 容器，它就是 AnnotationConfigApplicationContext，从名称就可以看出它是一个基于注解的 IoC 容器。之所以研究它，是因为Spring Boot 装配和获取 Bean 的方法与它如出一辙。\n\n下面来看一个最为简单的例子。首先定义一个 Java简单对象（Plain Ordinary Java Object，POJO）文件 User.java，如代码清单 3-2 所示。\n\n```java\npackage com.springboot.chapter3.pojo;\n\npublic class User {\n    private Long id;\n    private String userName;\n    private String note;\n\n    // 省略setter和getter方法\n}\n```\n然后再定义一个 Java 配置文件 AppConfig.java，如代码清单 3-3 所示。\n\n```java\npackage com.springboot.chapter3.config;\n\nimport com.springboot.chapter3.pojo.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AppConfig {\n    @Bean(name = \"user\")\n    public User initUser() {\n        User user = new User();\n        user.setId(1L);\n        user.setUserName(\"user_name_1\");\n        user.setNote(\"note_1\");\n        return user;\n    }\n}\n```\n这里需要注意加粗的注解。@Configuration 代表这是一个 Java 配置文件，Spring 的容器会根据它来生成 IoC 容器去装配 Bean：@Bean 代表将 initUser 方法返回的 POJO 装配到 IoC 容器中，而其属性 name 定义这个 Bean 的名称，如果没有配置它，则将方法名称“initUser”作为 Bean 的名称保存到 Spring IoC 容器中。\n\n做好了这些，就可以使用 AnnotationConfigApplicationContext 来构建自己的 IoC 容器，如代码清单 3-4 所示。\n\n```java\npackage com.springboot.chapter3.config;\n\n\nimport com.springboot.chapter3.pojo.User;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\nimport java.util.logging.Logger;\n\n\npublic class IoCTest {\n    private static final Logger log = Logger.getLogger(IoCTest.class.getName());\n\n    public static void main(String[] args) {\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n        User user = ctx.getBean(User.class);\n        log.info(user.getId().toString());\n    }\n}\n\n```\n代码中将 Java 配置文件 AppConfig 传递给 AnnotationConfigApplicationContext 的构造方法，这样它就能够读取配置了。然后将配置里面的 Bean 装配到 IoC 容器中，于是可以使用 getBean 方法获取对应的 POJO，你可以看到下面的日志打印：\n\n![image](images/W0ntjjclR0cRfx9d2qlynjZFvQ1yu8nfw6qDzTiIKMY.png)\n\n显然，配置在配置文件中的名称为 user 的 Bean 已经被装配到 IoC 容器中，并且可以通过getBean 方法获取对应的 Bean，并建 Bean 的属性信息输出出来。当然这只是很简单的方法，而注解 @Bean 也不是唯一创建 Bean 的方法，还有其他的方法可以让 IoC 容器装配 Bean，而且 Bean 之间还有依赖的关系需要进一步处理。这是本章后面章节的主要内容了。\n\n## 3.2 装配你的 Bean\n在 Spring 中允许我们通过 XML 或者 Java 配置文件装配 Bean，但是由于 Spring Boot 是基于注解的方式，因此下面主要基于注解的方式来介绍 Spring 的用啊，以满足 Spring Boot 开发者的需要。\n\n### 3.2.1 通过扫描装配你的 Bean\n如果一个个的 Bean 使用注解 @Bean 注入 Spring IoC 容器中，那将是一件很麻烦的事情。好在 Spring 还允许我们进行扫描装配 Bean 到 IoC 容器中，对于扫描装配而言使用的注解是 @Component 和 @ComponentScan。@Component 是标明哪个类被扫描进入 Spring IoC 容器，而 @ComponentScan 则是标明采用何种策略去扫描装配到 Bean。\n\n这里我们首先把代码清单 3-2 中的 User.java 移到包 com.springboot.chapter3.config 内，然后对其进行修改，如代码清单 3-5 所示。\n\n```java\npackage com.springboot.chapter3.config;\n\nimport lombok.Data;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component(\"user\")\n@Data\npublic class User {\n    @Value(\"1\")\n    private Long id;\n    @Value(\"user_name_1\")\n    private String userName;\n    @Value(\"note_1\")\n    private String note;\n\n    // setter and getter\n}\n\n```\n这里的注解 @Component 表明这个类将被 Spring IoC 容器扫描装配，其中配置的“user”则是作为 Bean 的名称，当然你也可以不配置这个字符串，那么 IoC 容器就会把类名第一个字母作为小写，其他不变作为 Bean 名称放入到 IoC 容器中；注解 @Value 则是指定具体的值，使得 Spring IoC 给于对应的属性注入对应的值。为了让 Spring IoC 容器装配这个类，需要改造类 AppConfig，如代码清单 3-6 所示。\n\n```java\npackage com.springboot.chapter3.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@ComponentScan\npublic class AppConfig {\n}\n\n```\n这里加入了 @ComponentScan，意味着它会进行扫描，但是它只会扫描类 AppConfig 所在的当前包和其子包，之前把 User.java 移到包 com.springboot.chapter3.config 就是这样原因。这样就可以删掉之前使用 @Bean 标注的创建对象方法。然后进行测试，测试代码如代码清单 3-7 所示。\n\n```java\npackage com.springboot.chapter3.config;\n\n\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\nimport java.util.logging.Logger;\n\n\npublic class IoCTest {\n    private static final Logger log = Logger.getLogger(IoCTest.class.getName());\n\n    public static void main(String[] args) {\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n        User user = ctx.getBean(User.class);\n        log.info(user.getId().toString());\n    }\n}\n\n```\n这样就能够运行了。然而为了使得 User类能够被扫描，上面我们把它迁移到了本不该放置它的配置包，这样显然就不太合理了。为了更加合理，@ComponentScan 还允许我们自定义扫描的包。下面探讨它的配置项。\n\n首先探讨 @ComponentScan 的源码，如代码清单 3-8 所示。\n\n```java\npackage org.springframework.context.annotation;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Documented\n// 在一个类中可重复定义\n@Repeatable(ComponentScans.class)\npublic @interface ComponentScan {\n\n    // 定义扫描的包\n    @AliasFor(\"basePackages\")\n    String[] value() default {};\n\n    // 定义扫描的包\n    @AliasFor(\"value\")\n    String[] basePackages() default {};\n\n    // 定义扫描的类\n    Class<?>[] basePackageClasses() default {};\n\n    // Bean name 生成器\n    Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;\n\n    // 作用域解析器\n    Class<? extends ScopeMetadataResolver> scopeResolver() default AnnotationScopeMetadataResolver.class;\n\n    // 作用域代理模式\n    ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;\n\n    // 资源匹配模式\n    String resourcePattern() default ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;\n\n    // 是否启用默认的过滤器\n    boolean useDefaultFilters() default true;\n\n    // 当满足过滤器的条件时扫描\n    Filter[] includeFilters() default {};\n\n    // 当不满足过滤器的条件时扫描\n    Filter[] excludeFilters() default {};\n\n    // 是否延迟初始化\n    boolean lazyInit() default false;\n\n    // 定义过滤器\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target({})\n    @interface Filter {\n\n        // 过滤器类型，可以按注解类型或者正则式等过滤\n        FilterType type() default FilterType.ANNOTATION;\n\n        // 定义过滤的类\n        @AliasFor(\"classes\")\n        Class<?>[] value() default {};\n\n        // 定义过滤的类\n        @AliasFor(\"value\")\n        Class<?>[] classes() default {};\n\n        // 匹配方式\n        String[] pattern() default {};\n\n    }\n}\n```\n上面加粗的代码是最常用的配置项，需要了解它们的使用方法。首先可以通过配置项 basePackages 定义扫描的包名，在没有定义的情况下，它只会扫描当前包和其子包下的路径；还可以通过 basePackageClasses 定义扫描的类；其中还有 includeFilters 和 excludeFilters，includeFilters 是定义满足过滤器（Filter）条件的 Bean 才去扫描，excludeFilters 则是排除过滤器条件的 Bean，它们都需要通过一个注解 @Filter 去定义，它有一个type 类型，这里可以定义为注解或者正则式等类型。classes 定义注解类，pattern 定义正则式类。\n\n此时我们再把 User 类放到包 com.springboot.chapter3.pojo 中，这样 User 和 AppConfig 就不再同包，那么我们把 AppConfig 中的注解修改为：\n\n```java\n@ComponentScan(\"com.springboot.chapter3.*\")\n```\n或\n\n```java\n@ComponentScan(basePackages = {\"com.springboot.chapter3.pojo\"})\n```\n或\n\n```java\n@ComponentScan(basePackageClasses = {User.class})\n```\n无论采用何种方式都能够使得 IoC 容器去扫描 User 类，而包名可以采用正则去匹配。但是有时候我们的需求是想扫描一些包，将一些 Bean 装配到 Spring IoC 容器中，而不是想加载这个包里面的某些 Bean。比方说，现在我们有一个 UserService 类，为了标注它为服务类，将类标注 @Service（该标准注入了 @Component，所以在默认的情况下它会被 Spring 扫描装配到 IoC 容器中），这里再假设我们采用了策略：\n\n```java\n@ComponentScan(\"com.springboot.chapter3.*\")\n```\n这样对于 com.springboot.chapter3.service 和 com.springboot.chapter3.pojo，这两个包都会被扫描，此时我们定义 UserService 类如代码清单 3-9 所示。\n\n```java\npackage com.springboot.chapter3.service;\n\nimport com.springboot.chapter3.pojo.User;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserService {\n\n    public void printUser(User user) {\n        System.out.println(\"编号：\" + user.getId());\n        System.out.println(\"用户名称：\" + user.getUserName());\n        System.out.println(\"备注：\" + user.getNote());\n    }\n}\n```\n按以上的装配策略，它将会被扫描到 Spring IoC 容器中。为了不被装配，需要把扫描的策略修改为：\n\n```java\n@ComponentScan(value = \"com.springboot.chapter3.*\", excludeFilters = {@ComponentScan.Filter(classes = {Provider.Service.class})})\n```\n这样，由于加入了 excludeFilters 的配置，使标注了@Service 的类将不被 IoC 容器扫描注入，这样就可以把 UserService 类排除到 Spring IoC 容器中了。事实上，之前在 Spring Boot 上述实例中看到的注解@SpringBootApplication 也注入了@ComponentScan，这里不妨探索其源码，如代码清单 3-10 所示。\n\n```java\npackage org.springframework.boot.autoconfigure;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.TYPE)\n@Retention(java.lang.annotation.RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootApplication\n@EnableAutoConfiguration\n// 自定义排除的扫描类\n@ComponentScan(excludeFilters = {\n        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n\n    // 通过类型排除自动配置类\n    @AliasFor(annotation = EnableAutoConfiguration.class, attribute = \"exclude\")\n    Class<?>[] exclude() default {};\n\n    // 通过名称排除自动配置类\n    @AliasFor(annotation = EnableAutoConfiguration.class, attribute = \"excludeName\")\n    String[] excludeName() default {};\n\n    // 定义扫描的包\n    @AliasFor(annotation = ComponentScan.class, attribute = \"basePackages\")\n    String[] scanBasePackages() default {};\n\n    // 定义扫描的类\n    @AliasFor(annotation = ComponentScan.class, attribute = \"basePackageClasses\")\n    Class<?>[] scanBasePackageClasses() default {};\n}\n```\n显然，通过它就能够定义扫描哪些包。但是这里需要特别注意的是，它提供的 exclude 和 excludeName 两个方法是对于其内部的自动配置类才会生效的。为了能够排除其他类，还可以再加入@ComponentScan以达到我们的目的。例如，扫描 User 而不扫描 UserService，可以把启动配置文件写成：\n\n```java\n@SpringBootApplication\n@ComponentScan(basePackage = {\"com.springboot.chapter3\"},excludeFilters = {@Filter{classes = Service.class})\n```\n这样就能扫描指定对应的包并排除对应的类了。\n\n### 3.2.2 自定义第三方 Bean\n现实的 Java 的应用往往需要引入许多来自第三方的包，并且很有可能希望把第三方包的类对象也放入到 Spring IoC 容器中，这时@Bean 注解就可以发挥作用了。\n\n例如，要引入一个 DBCP 数据源，我们先在 pom.xml上加入项目所需要 DBCP 包和数据库 MySQL 驱动程序的依赖，如代码清单 3-11 所示。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.springboot</groupId>\n    <artifactId>chapter3</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>chapter3</name>\n    <description>chapter3</description>\n    <properties>\n        <java.version>8</java.version>\n    </properties>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>6.0.10</version>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>1.18.26</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.commons</groupId>\n            <artifactId>commons-dbcp2</artifactId>\n            <version>2.9.0</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>8.0.33</version>\n        </dependency>\n    </dependencies>\n\n</project>\n\n```\n这样 DBCP 和数据库驱动就被加入到了项目中，接着将使用它提供的机制来生成数据源。这时候，可以把代码清单 3-12 中的代码放置到 AppConfig.java 中。\n\n```java\npackage com.springboot.chapter3.config;\n\nimport org.apache.commons.dbcp2.BasicDataSourceFactory;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\nimport javax.sql.DataSource;\nimport java.security.Provider;\nimport java.util.Properties;\n\n@Configuration\n@ComponentScan(value = \"com.springboot.chapter3.*\", excludeFilters = {@ComponentScan.Filter(classes = {Provider.Service.class})})\npublic class AppConfig {\n    @Bean(name = \"dataSource\")\n    public DataSource getDataSource() {\n        Properties props = new Properties();\n        props.setProperty(\"driver\", \"com.mysql.jdbc.Driver\");\n        props.setProperty(\"url\", \"jdbc:mysql://localhost:3306/chapter3\");\n        props.setProperty(\"username\", \"root\");\n        props.setProperty(\"password\", \"123456\");\n        DataSource dataSource = null;\n        try {\n            dataSource = BasicDataSourceFactory.createDataSource(props);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return dataSource;\n    }\n}\n\n```\n这里通过 @Bean 定义了其配置项 name 为“dataSource”，那么 Spring 就会把它返回的对象用名称“dataSource”保存到 IoC 容器中。当然，你也可以不填写这个名称，那么它就会用你的方法名称作为 Bean 名称保存到 IoC 容器中。通过这样，就可以将第三方包的类装配到 Spring IoC 容器中了。\n\n## 3.3 依赖注入\n本章的开始讲述了 Spring IoC 的两个作用，上一节只讨论了如何将 Bean 装配到 IoC 容器中，对于如何进行获取，还有一个作用没有谈及，那就是 Bean 之间的依赖，在 Spring IoC 的概念中，我们称为依赖注入（Dependency Injection，DI）。\n\n例如，人类（Person）有时候利用一些动物（Animal）去完成一些事情，比方说狗（Dog）是用来看门的，猫（Cat）是用来抓老鼠的，鹦鹉（Parrot）是用来迎客的……于是做一些事情就依赖于那些可爱的动物了，如图 3-2 所示。\n\n为了更好地展示这个过程，首先来定义两个接口，一个是人类（Person），另一个是动物（Animal）。人类是通过动物去提供一些特殊服务的，如代码清单 3-13 所示。\n\n```java\npackage com.springboot.chapter3.pojo.definition;\n\npublic interface Person {\n\n    // 使用动物服务\n    void service();\n\n    // 设置动物\n    void setAnimal(Animal animal);\n}\n```\n```java\npackage com.springboot.chapter3.pojo.definition;\n\npublic interface Animal {\n    void use();\n}\n```\n这样我们就拥有了两个接口。接下来我们需要两个实现类，如代码亲的那 3-14 所示。\n\n```java\npackage com.springboot.chapter3.pojo;\n\nimport com.springboot.chapter3.pojo.definition.Animal;\nimport com.springboot.chapter3.pojo.definition.Person;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class BusinessPerson implements Person {\n\n    @Autowired\n    private Animal animal = null;\n\n    @Override\n    public void service() {\n        this.animal.use();\n    }\n\n    @Override\n    public void setAnimal(Animal animal) {\n        this.animal = animal;\n    }\n}\n```\n```java\npackage com.springboot.chapter3.pojo;\n\nimport com.springboot.chapter3.pojo.definition.Animal;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class Dog implements Animal {\n    @Override\n    public void use() {\n        System.out.println(\"狗【\" + Dog.class.getSimpleName() + \"】是看门用的。\");\n    }\n}\n```\n这里应注意加粗的注解 @Autowired，这也是我们在 Spring 中最常用的注解之一，十分重要，它会根据属性的类型（by type）找到对应的 Bean 进行注入。这里的 Dog 类是动物的一种，所以 Spring IoC 容器会把 Dog 的实例注入 BusinessPerson 中。这样通过 Spring IoC 容器获取 BusinessPerson 实例的时候就能够使用 Dog 实例来提供服务了，下面是测试的代码。\n\n```java\npackage com.springboot.chapter3.config;\n\n\nimport com.springboot.chapter3.pojo.BusinessPerson;\nimport com.springboot.chapter3.pojo.definition.Person;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\nimport java.util.logging.Logger;\n\n\npublic class IoCTest {\n    private static final Logger log = Logger.getLogger(IoCTest.class.getName());\n\n    public static void main(String[] args) {\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n        Person person = ctx.getBean(BusinessPerson.class);\n        person.service();\n    }\n}\n```\n测试一下，就可以得到下面的日志：\n\n```bash\n狗【Dog】是看门用的。\n```\n显然，测试是成功的，这个时候 Spring IoC 容器已经通过注解 @Autowired 成功地将 Dog 注入到了 BusinessPerson 实例中。但是这只是一个比较简单的例子，我们有必要继续探讨 @Autowired。\n\n### 3.3.1 注解@Autowired\n@Autowired 是我们使用得最多的注解之一，因此在这里需要进一步地探讨它。它注入的机制最基本的一条是根据类型（by type），我们回顾 IoC 容器的顶级接口 BeanFactory，就可以知道 IoC 容器是通过 getBean 方法获取对应 Bean 的，而 getBean 又支持根据类型（by type）或者根据名称（by name）。在回到上面的例子，我们只是创建了一个动物——狗，而实际上动物还可以有猫（Cat），猫可以为我们捉老鼠，于是我们又创建了一个猫的类，如代码清单 3-15 所示。\n\n```java\npackage com.springboot.chapter3.pojo;\n\nimport com.springboot.chapter3.pojo.definition.Animal;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class Cat implements Animal {\n    @Override\n    public void use() {\n        System.out.println(\"猫【\" + Cat.class.getSimpleName() + \"】是抓老鼠。\");\n    }\n}\n\n```\n好了，如果我们还使用着代码清单 3-14 中的 BusinessPerson 类，那么麻烦来了，因为这个类只是定义了一个动物属性（Animal），而我们却有两个动物，一个狗，一个猫，Spring IoC 如何注入呢？如果你还进行测试，很快你就可以看到 IoC 容器抛出异常，如下面的日志所示：\n\n```bash\n警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'businessPerson': Unsatisfied dependency expressed through field 'animal': No qualifying bean of type 'com.springboot.chapter3.pojo.definition.Animal' available: expected single matching bean but found 2: cat,dog\n```\n从加粗的日志可以看出，Spring IoC 容器并不能知道你需要注入什么动物（是狗？是猫？）给 BusinessPerson 类对象，从而引起错误的发生。那么使用@Autowired 能处理这个问题吗？答案是肯定的。假设我们目前需要的是狗提供服务，那么可以把属性名称转化为 dog，也就是原来的\n\n```java\n    @Autowired\n    private Animal animal = null;\n```\n修改为\n\n```java\n    @Autowired\n    private Animal dog = null;\n```\n这里，我们只是将属性的名称从 animal 修改为了 dog，那么我们再测试的时候，你可以看到是采用狗来提供服务的。那是因为 @Autowired 提供这样的规则，首先它会根据类型找到对应的 Bean，如果对应类型的 Bean 不是唯一的，那么它会根据其属性名称和 Bean 的名称进行匹配。如果匹配得上，就会使用该 Bean；如果还无法匹配，就会抛出异常。\n\n这里还要注意的是 @Autowired 是一个默认必须找到对应 Bean 的注解，如果不能确定其标注属性一定会存在并且允许这个被标注的属性为 null，那么你可以配置 @Autowired 属性 required 为 false，例如，像下面一样：\n\n```java\n    @Autowired(required = false)\n```\n同样，它除了可以标注属性外，还可以标注方法，如 setAnimal 方法，如下所示：\n\n```java\n@Override\n@Autowired\npublic void setAnimal (Animal animal) {\n    this.animal = animal;\n}\n```\n这样它也会使用 setAnimal 方法从 IoC 容器中找到对应的动物进行注入，甚至我们还可以使用在方法参数上，后面会再谈到它。\n\n### 3.3.2 消除歧义性——@Primary 和 @Quelifier\n在上面我们发现有猫有狗的时候，为了使@Autowired 能够继续使用，我们做了一个决定，将 BusinessPerson 的属性名称从 animal 修改为 dog。显然这是一个憋屈的做法，好好的一个动物，却被我们定义为了狗。产生注入失败的问题根本是按类型（by type）查找，正如动物可以有多种类型，这样会造成 Spring IoC 容器注入的困扰，我们把这样的一个问题称为歧义性。知道这个原因后，那么这两个注解是从哪个角度去解决这些问题的呢？这是本节要解决的问题。\n\n首先是一个注解 @Primary，它是一个修改优先权的注解，当我们有猫有狗的时候，假设这次需要使用猫，那么只需要在猫类的定义上加入@Primary 就可以了，类似下面这样：\n\n```java\npackage com.springboot.chapter3.pojo;\n\nimport com.springboot.chapter3.pojo.definition.Animal;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.stereotype.Component;\n\n@Component\n@Primary\npublic class Cat implements Animal {\n    @Override\n    public void use() {\n        System.out.println(\"猫【\" + Cat.class.getSimpleName() + \"】是抓老鼠。\");\n    }\n}\n```\n这里的 @Primary 的含义告诉 Spring IoC 容器，当发现有多个同样类型的 Bean 时，请优先使用我进行注入，于是再进行测试时会发现，系统将用猫 为你提供服务。因为当 Spring 进行注入的时候，虽然它发现存在多个动物，但因为 Cat 被标注为了 @Primary，所以优先采用 Cat 的实例进行了注入，这样就通过优先级的变换使得 IoC 容器知道注入哪个具体的实例来满足依赖注入。\n\n\n\n### 3.3.3 带有参数的构造方法类的装配\n## 3.4 生命周期\n## 3.5 使用属性文件\n## 3.6 条件装配 Bean\n## 3.7 Bean 的作用域\n## 3.8 使用@Profile\n## 3.9 引入 XML 配置 Bean\n## 3.10 使用 Spring EL","slug":"full-annotated-spring-ioc","published":1,"updated":"2024-01-19T19:04:12.980Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrl0f7pa0000hkuy5695g6is","content":"<h1 id=\"第-3-章-全注解下的-Spring-IoC\"><a href=\"#第-3-章-全注解下的-Spring-IoC\" class=\"headerlink\" title=\"第 3 章 全注解下的 Spring IoC\"></a>第 3 章 全注解下的 Spring IoC</h1><p>本章先探讨 Spring 的控制反转（IoC）的应用。Spring 最成功的是其提出的理念，而不是技术本身。它所依赖的两个核心概念，一个是控制反转（Inversion of Controller，IoC）另一个是面向切面编程（Aspect Oriented Programming，AOP）。IoC 容器是 Spring 的核心，可以说 Spring 是一种基于 IoC 容器编程的框架。因为 Spring Boot 是基于注解的开发 Spring IoC，所以我们使用全注解的方式讲述 Spring IoC 技术，为后续章节打下基础。</p>\n<p>IoC 是一种通过描述来生成或者获取对象的技术，而这个技术不是 Spring 甚至不是 Java 独有的。对于 Java 的初学者更多的时候所熟悉的是使用 new 关键字来创建对象，而在 Spring 中则不是，它是通过描述来创建对象。只是 Spring Boot 并不建议使用 XML，而是通过注解的描述生成对象，所以本章主要是通过注解来介绍 Spring IoC 技术。</p>\n<p>一个系统可以生成各种对象，并且这些对象都需要进行管理。还值得一提的是，对象之间并不是孤立的，它们之间还可能存在依赖的关系。例如，一个班级是由多个老师和同学组成的，那么班级就依赖于多个老师和同学了。为此 Spring 还提供了依赖注入的功能，使得我们能够通过描述来管理各个对象之间的关系。</p>\n<p>为了描述上述的班级、同学和老师这 3 个对象关系，我们需要一个容器。在 Spring 中把每一个需要管理的对象称为 Spring Bean（简称 Bean），而 Spring 管理这些 Bean 的容器，被我们称为 Spring IoC 容器（或者简称 IoC 容器）。IoC 容器需要具备两个基本的功能：</p>\n<ul>\n<li>通过描述管理 Bean，包括发布和获取 Bean；</li>\n<li>通过描述完成 Bean 之间的依赖关系。</li>\n</ul>\n<p>在使用 IoC 之前，需要对 Spring IoC 容器有一个基本的认识。</p>\n<h2 id=\"3-1-IoC-容器简介\"><a href=\"#3-1-IoC-容器简介\" class=\"headerlink\" title=\"3.1 IoC 容器简介\"></a>3.1 IoC 容器简介</h2><p>Spring IoC 容器是一个管理 Bean 的容器，在 Spring 的定义中，它要求所有的 IoC 容器都需要实现接口 BeanFactory，它是一个顶级容器接口。为了增加对它的理解，我们首先阅读其源码，并讨论几个重要的方法。接口源码如代码清单 3-1 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.beans.factory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.BeansException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.ResolvableType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">BeanFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 前缀</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">FACTORY_BEAN_PREFIX</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&amp;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 多个 getBean 方法</span></span><br><span class=\"line\">    Object <span class=\"title function_\">getBean</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> BeansException;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;T&gt; T <span class=\"title function_\">getBean</span><span class=\"params\">(String name, Class&lt;T&gt; requiredType)</span> <span class=\"keyword\">throws</span> BeansException;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;T&gt; T <span class=\"title function_\">getBean</span><span class=\"params\">(Class&lt;T&gt; requiredType)</span> <span class=\"keyword\">throws</span> BeansException;</span><br><span class=\"line\"></span><br><span class=\"line\">    Object <span class=\"title function_\">getBean</span><span class=\"params\">(String name, Object... args)</span> <span class=\"keyword\">throws</span> BeansException;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;T&gt; T <span class=\"title function_\">getBean</span><span class=\"params\">(Class&lt;T&gt; requiredType, Object... args)</span> <span class=\"keyword\">throws</span> BeansException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 是否包含 Bean</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">containsBean</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Bean 是否是单例</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">isSingleton</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Bean 是否是原型</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">isPrototype</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 是否类型匹配</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">isTypeMatch</span><span class=\"params\">(String name, ResolvableType typeToMatch)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">isTypeMatch</span><span class=\"params\">(String name, Class&lt;?&gt; typeToMatch)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 Bean 的类型</span></span><br><span class=\"line\">    Class&lt;?&gt; getType(String name) <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 Bean 的别名</span></span><br><span class=\"line\">    String[] getAliases(String name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码中加入了中文注释，通过它们就可以理解这些方法的含义。这里值得注意的是接口中的几个方法。首先我们看到了多个 getBean 方法，这也是 IoC 容器最重要的方法之一，它的意义是从 IoC 容器中获取 Bean。而从多个 getBean 方法中可以看到有按类型（by type）获取 Bean 的，也有按名称（by name）获取 Bean 的，这就意味着在 Spring IoC 容器中，允许我们按类型或者名称获取 Bean，这对理解后面将讲到的 Spring 的依赖注入（Dependency Injection，DI）是十分重要的。</p>\n<p>isSingleton 方法则判断 Bean 是否在 Spring IoC 中为单例。这里需要记住是在 Spring IoC 容器中，默认的情况下，Bean 都是以单例存在的。也就是使用 getBean 方法返回的都是同一个对象。与 isSingleton 方法相反的时 isPrototype 方法，如果它返回的是 true，那么当我们使用 getBean 方法获取 Bean 的时候，Spring IoC 容器就会创建一个新的 Bean 返回给调用者，这些与后面将讨论的 Bean 作用于相关。</p>\n<p>由于 BeanFactory 的功能还不够强大，因此 Spring 在 BeanFactory 的基础上，还设计了一个更为高级的接口 ApplicationContext。它是 BeanFactory 的子接口之一，在 Spring 的体系中 BeanFactory 和 ApplicationContext 是最为重要的接口设计，在现实中我们使用的大部分 Spring IoC 容器是 ApplicationContext 接口的实现类，它们的关系如图 3-1 所示。</p>\n<p><img src=\"/images/uhw4BvOe-bbHfhH2O3USvEAbPYHU9BBByUD2gN1W614.png\" alt=\"image\"></p>\n<p>在图中可以看到，ApplicationContext 接口通过继承上级接口，进而继承 BeanFactory 接口，但是在 BeanFactory 的基础上，扩展了消息国际化接口（MessageSource）、环境可配置接口（EnvironmentCapable）、应用事件发布接口（ApplicationEventPublisher）和资源模式解析接口（ResourcePatternResolver），所以它的功能会更为强大。</p>\n<p>在 Spring Boot 当中我们主要是通过注解来装配 Bean 到 Spring IoC 容器中，为了贴近 Spring Boot 的需要，这里不再介绍与 XML 相关的 IoC 容器，而主要介绍一个基于注解的 IoC 容器，它就是 AnnotationConfigApplicationContext，从名称就可以看出它是一个基于注解的 IoC 容器。之所以研究它，是因为Spring Boot 装配和获取 Bean 的方法与它如出一辙。</p>\n<p>下面来看一个最为简单的例子。首先定义一个 Java简单对象（Plain Ordinary Java Object，POJO）文件 User.java，如代码清单 3-2 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.pojo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String note;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 省略setter和getter方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后再定义一个 Java 配置文件 AppConfig.java，如代码清单 3-3 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.User;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;user&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">initUser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>();</span><br><span class=\"line\">        user.setId(<span class=\"number\">1L</span>);</span><br><span class=\"line\">        user.setUserName(<span class=\"string\">&quot;user_name_1&quot;</span>);</span><br><span class=\"line\">        user.setNote(<span class=\"string\">&quot;note_1&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意加粗的注解。@Configuration 代表这是一个 Java 配置文件，Spring 的容器会根据它来生成 IoC 容器去装配 Bean：@Bean 代表将 initUser 方法返回的 POJO 装配到 IoC 容器中，而其属性 name 定义这个 Bean 的名称，如果没有配置它，则将方法名称“initUser”作为 Bean 的名称保存到 Spring IoC 容器中。</p>\n<p>做好了这些，就可以使用 AnnotationConfigApplicationContext 来构建自己的 IoC 容器，如代码清单 3-4 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.User;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.ApplicationContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.logging.Logger;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IoCTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> Logger.getLogger(IoCTest.class.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> ctx.getBean(User.class);</span><br><span class=\"line\">        log.info(user.getId().toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>代码中将 Java 配置文件 AppConfig 传递给 AnnotationConfigApplicationContext 的构造方法，这样它就能够读取配置了。然后将配置里面的 Bean 装配到 IoC 容器中，于是可以使用 getBean 方法获取对应的 POJO，你可以看到下面的日志打印：</p>\n<p><img src=\"/images/W0ntjjclR0cRfx9d2qlynjZFvQ1yu8nfw6qDzTiIKMY.png\" alt=\"image\"></p>\n<p>显然，配置在配置文件中的名称为 user 的 Bean 已经被装配到 IoC 容器中，并且可以通过getBean 方法获取对应的 Bean，并建 Bean 的属性信息输出出来。当然这只是很简单的方法，而注解 @Bean 也不是唯一创建 Bean 的方法，还有其他的方法可以让 IoC 容器装配 Bean，而且 Bean 之间还有依赖的关系需要进一步处理。这是本章后面章节的主要内容了。</p>\n<h2 id=\"3-2-装配你的-Bean\"><a href=\"#3-2-装配你的-Bean\" class=\"headerlink\" title=\"3.2 装配你的 Bean\"></a>3.2 装配你的 Bean</h2><p>在 Spring 中允许我们通过 XML 或者 Java 配置文件装配 Bean，但是由于 Spring Boot 是基于注解的方式，因此下面主要基于注解的方式来介绍 Spring 的用啊，以满足 Spring Boot 开发者的需要。</p>\n<h3 id=\"3-2-1-通过扫描装配你的-Bean\"><a href=\"#3-2-1-通过扫描装配你的-Bean\" class=\"headerlink\" title=\"3.2.1 通过扫描装配你的 Bean\"></a>3.2.1 通过扫描装配你的 Bean</h3><p>如果一个个的 Bean 使用注解 @Bean 注入 Spring IoC 容器中，那将是一件很麻烦的事情。好在 Spring 还允许我们进行扫描装配 Bean 到 IoC 容器中，对于扫描装配而言使用的注解是 @Component 和 @ComponentScan。@Component 是标明哪个类被扫描进入 Spring IoC 容器，而 @ComponentScan 则是标明采用何种策略去扫描装配到 Bean。</p>\n<p>这里我们首先把代码清单 3-2 中的 User.java 移到包 com.springboot.chapter3.config 内，然后对其进行修改，如代码清单 3-5 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.Data;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component(&quot;user&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;1&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;user_name_1&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;note_1&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String note;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// setter and getter</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里的注解 @Component 表明这个类将被 Spring IoC 容器扫描装配，其中配置的“user”则是作为 Bean 的名称，当然你也可以不配置这个字符串，那么 IoC 容器就会把类名第一个字母作为小写，其他不变作为 Bean 名称放入到 IoC 容器中；注解 @Value 则是指定具体的值，使得 Spring IoC 给于对应的属性注入对应的值。为了让 Spring IoC 容器装配这个类，需要改造类 AppConfig，如代码清单 3-6 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里加入了 @ComponentScan，意味着它会进行扫描，但是它只会扫描类 AppConfig 所在的当前包和其子包，之前把 User.java 移到包 com.springboot.chapter3.config 就是这样原因。这样就可以删掉之前使用 @Bean 标注的创建对象方法。然后进行测试，测试代码如代码清单 3-7 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.ApplicationContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.logging.Logger;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IoCTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> Logger.getLogger(IoCTest.class.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> ctx.getBean(User.class);</span><br><span class=\"line\">        log.info(user.getId().toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这样就能够运行了。然而为了使得 User类能够被扫描，上面我们把它迁移到了本不该放置它的配置包，这样显然就不太合理了。为了更加合理，@ComponentScan 还允许我们自定义扫描的包。下面探讨它的配置项。</p>\n<p>首先探讨 @ComponentScan 的源码，如代码清单 3-8 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.context.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Documented;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Repeatable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"comment\">// 在一个类中可重复定义</span></span><br><span class=\"line\"><span class=\"meta\">@Repeatable(ComponentScans.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> ComponentScan &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义扫描的包</span></span><br><span class=\"line\">    <span class=\"meta\">@AliasFor(&quot;basePackages&quot;)</span></span><br><span class=\"line\">    String[] value() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义扫描的包</span></span><br><span class=\"line\">    <span class=\"meta\">@AliasFor(&quot;value&quot;)</span></span><br><span class=\"line\">    String[] basePackages() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义扫描的类</span></span><br><span class=\"line\">    Class&lt;?&gt;[] basePackageClasses() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Bean name 生成器</span></span><br><span class=\"line\">    Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">BeanNameGenerator</span>&gt; nameGenerator() <span class=\"keyword\">default</span> BeanNameGenerator.class;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 作用域解析器</span></span><br><span class=\"line\">    Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">ScopeMetadataResolver</span>&gt; scopeResolver() <span class=\"keyword\">default</span> AnnotationScopeMetadataResolver.class;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 作用域代理模式</span></span><br><span class=\"line\">    ScopedProxyMode <span class=\"title function_\">scopedProxy</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> ScopedProxyMode.DEFAULT;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 资源匹配模式</span></span><br><span class=\"line\">    String <span class=\"title function_\">resourcePattern</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 是否启用默认的过滤器</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">useDefaultFilters</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当满足过滤器的条件时扫描</span></span><br><span class=\"line\">    Filter[] includeFilters() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当不满足过滤器的条件时扫描</span></span><br><span class=\"line\">    Filter[] excludeFilters() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 是否延迟初始化</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">lazyInit</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义过滤器</span></span><br><span class=\"line\">    <span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\">    <span class=\"meta\">@Target(&#123;&#125;)</span></span><br><span class=\"line\">    <span class=\"meta\">@interface</span> Filter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 过滤器类型，可以按注解类型或者正则式等过滤</span></span><br><span class=\"line\">        FilterType <span class=\"title function_\">type</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> FilterType.ANNOTATION;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 定义过滤的类</span></span><br><span class=\"line\">        <span class=\"meta\">@AliasFor(&quot;classes&quot;)</span></span><br><span class=\"line\">        Class&lt;?&gt;[] value() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 定义过滤的类</span></span><br><span class=\"line\">        <span class=\"meta\">@AliasFor(&quot;value&quot;)</span></span><br><span class=\"line\">        Class&lt;?&gt;[] classes() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 匹配方式</span></span><br><span class=\"line\">        String[] pattern() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面加粗的代码是最常用的配置项，需要了解它们的使用方法。首先可以通过配置项 basePackages 定义扫描的包名，在没有定义的情况下，它只会扫描当前包和其子包下的路径；还可以通过 basePackageClasses 定义扫描的类；其中还有 includeFilters 和 excludeFilters，includeFilters 是定义满足过滤器（Filter）条件的 Bean 才去扫描，excludeFilters 则是排除过滤器条件的 Bean，它们都需要通过一个注解 @Filter 去定义，它有一个type 类型，这里可以定义为注解或者正则式等类型。classes 定义注解类，pattern 定义正则式类。</p>\n<p>此时我们再把 User 类放到包 com.springboot.chapter3.pojo 中，这样 User 和 AppConfig 就不再同包，那么我们把 AppConfig 中的注解修改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(&quot;com.springboot.chapter3.*&quot;)</span></span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &#123;&quot;com.springboot.chapter3.pojo&quot;&#125;)</span></span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackageClasses = &#123;User.class&#125;)</span></span><br></pre></td></tr></table></figure>\n<p>无论采用何种方式都能够使得 IoC 容器去扫描 User 类，而包名可以采用正则去匹配。但是有时候我们的需求是想扫描一些包，将一些 Bean 装配到 Spring IoC 容器中，而不是想加载这个包里面的某些 Bean。比方说，现在我们有一个 UserService 类，为了标注它为服务类，将类标注 @Service（该标准注入了 @Component，所以在默认的情况下它会被 Spring 扫描装配到 IoC 容器中），这里再假设我们采用了策略：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(&quot;com.springboot.chapter3.*&quot;)</span></span><br></pre></td></tr></table></figure>\n<p>这样对于 com.springboot.chapter3.service 和 com.springboot.chapter3.pojo，这两个包都会被扫描，此时我们定义 UserService 类如代码清单 3-9 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.User;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printUser</span><span class=\"params\">(User user)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;编号：&quot;</span> + user.getId());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;用户名称：&quot;</span> + user.getUserName());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;备注：&quot;</span> + user.getNote());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>按以上的装配策略，它将会被扫描到 Spring IoC 容器中。为了不被装配，需要把扫描的策略修改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(value = &quot;com.springboot.chapter3.*&quot;, excludeFilters = &#123;@ComponentScan.Filter(classes = &#123;Provider.Service.class&#125;)&#125;)</span></span><br></pre></td></tr></table></figure>\n<p>这样，由于加入了 excludeFilters 的配置，使标注了@Service 的类将不被 IoC 容器扫描注入，这样就可以把 UserService 类排除到 Spring IoC 容器中了。事实上，之前在 Spring Boot 上述实例中看到的注解@SpringBootApplication 也注入了@ComponentScan，这里不妨探索其源码，如代码清单 3-10 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.boot.autoconfigure;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Documented;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.ElementType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Inherited;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Retention;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(java.lang.annotation.RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span></span><br><span class=\"line\"><span class=\"comment\">// 自定义排除的扫描类</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(excludeFilters = &#123;</span></span><br><span class=\"line\"><span class=\"meta\">        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class=\"line\"><span class=\"meta\">        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SpringBootApplication &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过类型排除自动配置类</span></span><br><span class=\"line\">    <span class=\"meta\">@AliasFor(annotation = EnableAutoConfiguration.class, attribute = &quot;exclude&quot;)</span></span><br><span class=\"line\">    Class&lt;?&gt;[] exclude() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过名称排除自动配置类</span></span><br><span class=\"line\">    <span class=\"meta\">@AliasFor(annotation = EnableAutoConfiguration.class, attribute = &quot;excludeName&quot;)</span></span><br><span class=\"line\">    String[] excludeName() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义扫描的包</span></span><br><span class=\"line\">    <span class=\"meta\">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)</span></span><br><span class=\"line\">    String[] scanBasePackages() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义扫描的类</span></span><br><span class=\"line\">    <span class=\"meta\">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;)</span></span><br><span class=\"line\">    Class&lt;?&gt;[] scanBasePackageClasses() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显然，通过它就能够定义扫描哪些包。但是这里需要特别注意的是，它提供的 exclude 和 excludeName 两个方法是对于其内部的自动配置类才会生效的。为了能够排除其他类，还可以再加入@ComponentScan以达到我们的目的。例如，扫描 User 而不扫描 UserService，可以把启动配置文件写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackage = &#123;&quot;com.springboot.chapter3&quot;&#125;,excludeFilters = &#123;@Filter&#123;classes = Service.class&#125;)</span></span><br></pre></td></tr></table></figure>\n<p>这样就能扫描指定对应的包并排除对应的类了。</p>\n<h3 id=\"3-2-2-自定义第三方-Bean\"><a href=\"#3-2-2-自定义第三方-Bean\" class=\"headerlink\" title=\"3.2.2 自定义第三方 Bean\"></a>3.2.2 自定义第三方 Bean</h3><p>现实的 Java 的应用往往需要引入许多来自第三方的包，并且很有可能希望把第三方包的类对象也放入到 Spring IoC 容器中，这时@Bean 注解就可以发挥作用了。</p>\n<p>例如，要引入一个 DBCP 数据源，我们先在 pom.xml上加入项目所需要 DBCP 包和数据库 MySQL 驱动程序的依赖，如代码清单 3-11 所示。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.springboot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>chapter3<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>chapter3<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>chapter3<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>8<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>6.0.10<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.projectlombok<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>lombok<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.18.26<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.commons<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>commons-dbcp2<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.9.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>8.0.33<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这样 DBCP 和数据库驱动就被加入到了项目中，接着将使用它提供的机制来生成数据源。这时候，可以把代码清单 3-12 中的代码放置到 AppConfig.java 中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.dbcp2.BasicDataSourceFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.sql.DataSource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.Provider;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Properties;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(value = &quot;com.springboot.chapter3.*&quot;, excludeFilters = &#123;@ComponentScan.Filter(classes = &#123;Provider.Service.class&#125;)&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;dataSource&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> DataSource <span class=\"title function_\">getDataSource</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Properties</span> <span class=\"variable\">props</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">        props.setProperty(<span class=\"string\">&quot;driver&quot;</span>, <span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class=\"line\">        props.setProperty(<span class=\"string\">&quot;url&quot;</span>, <span class=\"string\">&quot;jdbc:mysql://localhost:3306/chapter3&quot;</span>);</span><br><span class=\"line\">        props.setProperty(<span class=\"string\">&quot;username&quot;</span>, <span class=\"string\">&quot;root&quot;</span>);</span><br><span class=\"line\">        props.setProperty(<span class=\"string\">&quot;password&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">DataSource</span> <span class=\"variable\">dataSource</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            dataSource = BasicDataSourceFactory.createDataSource(props);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里通过 @Bean 定义了其配置项 name 为“dataSource”，那么 Spring 就会把它返回的对象用名称“dataSource”保存到 IoC 容器中。当然，你也可以不填写这个名称，那么它就会用你的方法名称作为 Bean 名称保存到 IoC 容器中。通过这样，就可以将第三方包的类装配到 Spring IoC 容器中了。</p>\n<h2 id=\"3-3-依赖注入\"><a href=\"#3-3-依赖注入\" class=\"headerlink\" title=\"3.3 依赖注入\"></a>3.3 依赖注入</h2><p>本章的开始讲述了 Spring IoC 的两个作用，上一节只讨论了如何将 Bean 装配到 IoC 容器中，对于如何进行获取，还有一个作用没有谈及，那就是 Bean 之间的依赖，在 Spring IoC 的概念中，我们称为依赖注入（Dependency Injection，DI）。</p>\n<p>例如，人类（Person）有时候利用一些动物（Animal）去完成一些事情，比方说狗（Dog）是用来看门的，猫（Cat）是用来抓老鼠的，鹦鹉（Parrot）是用来迎客的……于是做一些事情就依赖于那些可爱的动物了，如图 3-2 所示。</p>\n<p>为了更好地展示这个过程，首先来定义两个接口，一个是人类（Person），另一个是动物（Animal）。人类是通过动物去提供一些特殊服务的，如代码清单 3-13 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.pojo.definition;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用动物服务</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">service</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置动物</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">setAnimal</span><span class=\"params\">(Animal animal)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.pojo.definition;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">use</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们就拥有了两个接口。接下来我们需要两个实现类，如代码亲的那 3-14 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.pojo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.definition.Animal;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.definition.Person;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BusinessPerson</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Animal</span> <span class=\"variable\">animal</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">service</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.animal.use();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAnimal</span><span class=\"params\">(Animal animal)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.animal = animal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.pojo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.definition.Animal;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">use</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;狗【&quot;</span> + Dog.class.getSimpleName() + <span class=\"string\">&quot;】是看门用的。&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里应注意加粗的注解 @Autowired，这也是我们在 Spring 中最常用的注解之一，十分重要，它会根据属性的类型（by type）找到对应的 Bean 进行注入。这里的 Dog 类是动物的一种，所以 Spring IoC 容器会把 Dog 的实例注入 BusinessPerson 中。这样通过 Spring IoC 容器获取 BusinessPerson 实例的时候就能够使用 Dog 实例来提供服务了，下面是测试的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.BusinessPerson;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.definition.Person;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.ApplicationContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.logging.Logger;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IoCTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> Logger.getLogger(IoCTest.class.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> ctx.getBean(BusinessPerson.class);</span><br><span class=\"line\">        person.service();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试一下，就可以得到下面的日志：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">狗【Dog】是看门用的。</span><br></pre></td></tr></table></figure>\n<p>显然，测试是成功的，这个时候 Spring IoC 容器已经通过注解 @Autowired 成功地将 Dog 注入到了 BusinessPerson 实例中。但是这只是一个比较简单的例子，我们有必要继续探讨 @Autowired。</p>\n<h3 id=\"3-3-1-注解-Autowired\"><a href=\"#3-3-1-注解-Autowired\" class=\"headerlink\" title=\"3.3.1 注解@Autowired\"></a>3.3.1 注解@Autowired</h3><p>@Autowired 是我们使用得最多的注解之一，因此在这里需要进一步地探讨它。它注入的机制最基本的一条是根据类型（by type），我们回顾 IoC 容器的顶级接口 BeanFactory，就可以知道 IoC 容器是通过 getBean 方法获取对应 Bean 的，而 getBean 又支持根据类型（by type）或者根据名称（by name）。在回到上面的例子，我们只是创建了一个动物——狗，而实际上动物还可以有猫（Cat），猫可以为我们捉老鼠，于是我们又创建了一个猫的类，如代码清单 3-15 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.pojo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.definition.Animal;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">use</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;猫【&quot;</span> + Cat.class.getSimpleName() + <span class=\"string\">&quot;】是抓老鼠。&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>好了，如果我们还使用着代码清单 3-14 中的 BusinessPerson 类，那么麻烦来了，因为这个类只是定义了一个动物属性（Animal），而我们却有两个动物，一个狗，一个猫，Spring IoC 如何注入呢？如果你还进行测试，很快你就可以看到 IoC 容器抛出异常，如下面的日志所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class=\"string\">&#x27;businessPerson&#x27;</span>: Unsatisfied dependency expressed through field <span class=\"string\">&#x27;animal&#x27;</span>: No qualifying bean of <span class=\"built_in\">type</span> <span class=\"string\">&#x27;com.springboot.chapter3.pojo.definition.Animal&#x27;</span> available: expected single matching bean but found 2: <span class=\"built_in\">cat</span>,dog</span><br></pre></td></tr></table></figure>\n<p>从加粗的日志可以看出，Spring IoC 容器并不能知道你需要注入什么动物（是狗？是猫？）给 BusinessPerson 类对象，从而引起错误的发生。那么使用@Autowired 能处理这个问题吗？答案是肯定的。假设我们目前需要的是狗提供服务，那么可以把属性名称转化为 dog，也就是原来的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">Animal</span> <span class=\"variable\">animal</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>修改为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">Animal</span> <span class=\"variable\">dog</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>这里，我们只是将属性的名称从 animal 修改为了 dog，那么我们再测试的时候，你可以看到是采用狗来提供服务的。那是因为 @Autowired 提供这样的规则，首先它会根据类型找到对应的 Bean，如果对应类型的 Bean 不是唯一的，那么它会根据其属性名称和 Bean 的名称进行匹配。如果匹配得上，就会使用该 Bean；如果还无法匹配，就会抛出异常。</p>\n<p>这里还要注意的是 @Autowired 是一个默认必须找到对应 Bean 的注解，如果不能确定其标注属性一定会存在并且允许这个被标注的属性为 null，那么你可以配置 @Autowired 属性 required 为 false，例如，像下面一样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired(required = false)</span></span><br></pre></td></tr></table></figure>\n<p>同样，它除了可以标注属性外，还可以标注方法，如 setAnimal 方法，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAnimal</span> <span class=\"params\">(Animal animal)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.animal = animal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样它也会使用 setAnimal 方法从 IoC 容器中找到对应的动物进行注入，甚至我们还可以使用在方法参数上，后面会再谈到它。</p>\n<h3 id=\"3-3-2-消除歧义性——-Primary-和-Quelifier\"><a href=\"#3-3-2-消除歧义性——-Primary-和-Quelifier\" class=\"headerlink\" title=\"3.3.2 消除歧义性——@Primary 和 @Quelifier\"></a>3.3.2 消除歧义性——@Primary 和 @Quelifier</h3><p>在上面我们发现有猫有狗的时候，为了使@Autowired 能够继续使用，我们做了一个决定，将 BusinessPerson 的属性名称从 animal 修改为 dog。显然这是一个憋屈的做法，好好的一个动物，却被我们定义为了狗。产生注入失败的问题根本是按类型（by type）查找，正如动物可以有多种类型，这样会造成 Spring IoC 容器注入的困扰，我们把这样的一个问题称为歧义性。知道这个原因后，那么这两个注解是从哪个角度去解决这些问题的呢？这是本节要解决的问题。</p>\n<p>首先是一个注解 @Primary，它是一个修改优先权的注解，当我们有猫有狗的时候，假设这次需要使用猫，那么只需要在猫类的定义上加入@Primary 就可以了，类似下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.pojo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.definition.Animal;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Primary;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Primary</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">use</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;猫【&quot;</span> + Cat.class.getSimpleName() + <span class=\"string\">&quot;】是抓老鼠。&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的 @Primary 的含义告诉 Spring IoC 容器，当发现有多个同样类型的 Bean 时，请优先使用我进行注入，于是再进行测试时会发现，系统将用猫 为你提供服务。因为当 Spring 进行注入的时候，虽然它发现存在多个动物，但因为 Cat 被标注为了 @Primary，所以优先采用 Cat 的实例进行了注入，这样就通过优先级的变换使得 IoC 容器知道注入哪个具体的实例来满足依赖注入。</p>\n<h3 id=\"3-3-3-带有参数的构造方法类的装配\"><a href=\"#3-3-3-带有参数的构造方法类的装配\" class=\"headerlink\" title=\"3.3.3 带有参数的构造方法类的装配\"></a>3.3.3 带有参数的构造方法类的装配</h3><h2 id=\"3-4-生命周期\"><a href=\"#3-4-生命周期\" class=\"headerlink\" title=\"3.4 生命周期\"></a>3.4 生命周期</h2><h2 id=\"3-5-使用属性文件\"><a href=\"#3-5-使用属性文件\" class=\"headerlink\" title=\"3.5 使用属性文件\"></a>3.5 使用属性文件</h2><h2 id=\"3-6-条件装配-Bean\"><a href=\"#3-6-条件装配-Bean\" class=\"headerlink\" title=\"3.6 条件装配 Bean\"></a>3.6 条件装配 Bean</h2><h2 id=\"3-7-Bean-的作用域\"><a href=\"#3-7-Bean-的作用域\" class=\"headerlink\" title=\"3.7 Bean 的作用域\"></a>3.7 Bean 的作用域</h2><h2 id=\"3-8-使用-Profile\"><a href=\"#3-8-使用-Profile\" class=\"headerlink\" title=\"3.8 使用@Profile\"></a>3.8 使用@Profile</h2><h2 id=\"3-9-引入-XML-配置-Bean\"><a href=\"#3-9-引入-XML-配置-Bean\" class=\"headerlink\" title=\"3.9 引入 XML 配置 Bean\"></a>3.9 引入 XML 配置 Bean</h2><h2 id=\"3-10-使用-Spring-EL\"><a href=\"#3-10-使用-Spring-EL\" class=\"headerlink\" title=\"3.10 使用 Spring EL\"></a>3.10 使用 Spring EL</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第-3-章-全注解下的-Spring-IoC\"><a href=\"#第-3-章-全注解下的-Spring-IoC\" class=\"headerlink\" title=\"第 3 章 全注解下的 Spring IoC\"></a>第 3 章 全注解下的 Spring IoC</h1><p>本章先探讨 Spring 的控制反转（IoC）的应用。Spring 最成功的是其提出的理念，而不是技术本身。它所依赖的两个核心概念，一个是控制反转（Inversion of Controller，IoC）另一个是面向切面编程（Aspect Oriented Programming，AOP）。IoC 容器是 Spring 的核心，可以说 Spring 是一种基于 IoC 容器编程的框架。因为 Spring Boot 是基于注解的开发 Spring IoC，所以我们使用全注解的方式讲述 Spring IoC 技术，为后续章节打下基础。</p>\n<p>IoC 是一种通过描述来生成或者获取对象的技术，而这个技术不是 Spring 甚至不是 Java 独有的。对于 Java 的初学者更多的时候所熟悉的是使用 new 关键字来创建对象，而在 Spring 中则不是，它是通过描述来创建对象。只是 Spring Boot 并不建议使用 XML，而是通过注解的描述生成对象，所以本章主要是通过注解来介绍 Spring IoC 技术。</p>\n<p>一个系统可以生成各种对象，并且这些对象都需要进行管理。还值得一提的是，对象之间并不是孤立的，它们之间还可能存在依赖的关系。例如，一个班级是由多个老师和同学组成的，那么班级就依赖于多个老师和同学了。为此 Spring 还提供了依赖注入的功能，使得我们能够通过描述来管理各个对象之间的关系。</p>\n<p>为了描述上述的班级、同学和老师这 3 个对象关系，我们需要一个容器。在 Spring 中把每一个需要管理的对象称为 Spring Bean（简称 Bean），而 Spring 管理这些 Bean 的容器，被我们称为 Spring IoC 容器（或者简称 IoC 容器）。IoC 容器需要具备两个基本的功能：</p>\n<ul>\n<li>通过描述管理 Bean，包括发布和获取 Bean；</li>\n<li>通过描述完成 Bean 之间的依赖关系。</li>\n</ul>\n<p>在使用 IoC 之前，需要对 Spring IoC 容器有一个基本的认识。</p>\n<h2 id=\"3-1-IoC-容器简介\"><a href=\"#3-1-IoC-容器简介\" class=\"headerlink\" title=\"3.1 IoC 容器简介\"></a>3.1 IoC 容器简介</h2><p>Spring IoC 容器是一个管理 Bean 的容器，在 Spring 的定义中，它要求所有的 IoC 容器都需要实现接口 BeanFactory，它是一个顶级容器接口。为了增加对它的理解，我们首先阅读其源码，并讨论几个重要的方法。接口源码如代码清单 3-1 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.beans.factory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.BeansException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.ResolvableType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">BeanFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 前缀</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">FACTORY_BEAN_PREFIX</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&amp;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 多个 getBean 方法</span></span><br><span class=\"line\">    Object <span class=\"title function_\">getBean</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> BeansException;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;T&gt; T <span class=\"title function_\">getBean</span><span class=\"params\">(String name, Class&lt;T&gt; requiredType)</span> <span class=\"keyword\">throws</span> BeansException;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;T&gt; T <span class=\"title function_\">getBean</span><span class=\"params\">(Class&lt;T&gt; requiredType)</span> <span class=\"keyword\">throws</span> BeansException;</span><br><span class=\"line\"></span><br><span class=\"line\">    Object <span class=\"title function_\">getBean</span><span class=\"params\">(String name, Object... args)</span> <span class=\"keyword\">throws</span> BeansException;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;T&gt; T <span class=\"title function_\">getBean</span><span class=\"params\">(Class&lt;T&gt; requiredType, Object... args)</span> <span class=\"keyword\">throws</span> BeansException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 是否包含 Bean</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">containsBean</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Bean 是否是单例</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">isSingleton</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Bean 是否是原型</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">isPrototype</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 是否类型匹配</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">isTypeMatch</span><span class=\"params\">(String name, ResolvableType typeToMatch)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">isTypeMatch</span><span class=\"params\">(String name, Class&lt;?&gt; typeToMatch)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 Bean 的类型</span></span><br><span class=\"line\">    Class&lt;?&gt; getType(String name) <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 Bean 的别名</span></span><br><span class=\"line\">    String[] getAliases(String name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码中加入了中文注释，通过它们就可以理解这些方法的含义。这里值得注意的是接口中的几个方法。首先我们看到了多个 getBean 方法，这也是 IoC 容器最重要的方法之一，它的意义是从 IoC 容器中获取 Bean。而从多个 getBean 方法中可以看到有按类型（by type）获取 Bean 的，也有按名称（by name）获取 Bean 的，这就意味着在 Spring IoC 容器中，允许我们按类型或者名称获取 Bean，这对理解后面将讲到的 Spring 的依赖注入（Dependency Injection，DI）是十分重要的。</p>\n<p>isSingleton 方法则判断 Bean 是否在 Spring IoC 中为单例。这里需要记住是在 Spring IoC 容器中，默认的情况下，Bean 都是以单例存在的。也就是使用 getBean 方法返回的都是同一个对象。与 isSingleton 方法相反的时 isPrototype 方法，如果它返回的是 true，那么当我们使用 getBean 方法获取 Bean 的时候，Spring IoC 容器就会创建一个新的 Bean 返回给调用者，这些与后面将讨论的 Bean 作用于相关。</p>\n<p>由于 BeanFactory 的功能还不够强大，因此 Spring 在 BeanFactory 的基础上，还设计了一个更为高级的接口 ApplicationContext。它是 BeanFactory 的子接口之一，在 Spring 的体系中 BeanFactory 和 ApplicationContext 是最为重要的接口设计，在现实中我们使用的大部分 Spring IoC 容器是 ApplicationContext 接口的实现类，它们的关系如图 3-1 所示。</p>\n<p><img src=\"/images/uhw4BvOe-bbHfhH2O3USvEAbPYHU9BBByUD2gN1W614.png\" alt=\"image\"></p>\n<p>在图中可以看到，ApplicationContext 接口通过继承上级接口，进而继承 BeanFactory 接口，但是在 BeanFactory 的基础上，扩展了消息国际化接口（MessageSource）、环境可配置接口（EnvironmentCapable）、应用事件发布接口（ApplicationEventPublisher）和资源模式解析接口（ResourcePatternResolver），所以它的功能会更为强大。</p>\n<p>在 Spring Boot 当中我们主要是通过注解来装配 Bean 到 Spring IoC 容器中，为了贴近 Spring Boot 的需要，这里不再介绍与 XML 相关的 IoC 容器，而主要介绍一个基于注解的 IoC 容器，它就是 AnnotationConfigApplicationContext，从名称就可以看出它是一个基于注解的 IoC 容器。之所以研究它，是因为Spring Boot 装配和获取 Bean 的方法与它如出一辙。</p>\n<p>下面来看一个最为简单的例子。首先定义一个 Java简单对象（Plain Ordinary Java Object，POJO）文件 User.java，如代码清单 3-2 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.pojo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String note;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 省略setter和getter方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后再定义一个 Java 配置文件 AppConfig.java，如代码清单 3-3 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.User;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;user&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">initUser</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>();</span><br><span class=\"line\">        user.setId(<span class=\"number\">1L</span>);</span><br><span class=\"line\">        user.setUserName(<span class=\"string\">&quot;user_name_1&quot;</span>);</span><br><span class=\"line\">        user.setNote(<span class=\"string\">&quot;note_1&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意加粗的注解。@Configuration 代表这是一个 Java 配置文件，Spring 的容器会根据它来生成 IoC 容器去装配 Bean：@Bean 代表将 initUser 方法返回的 POJO 装配到 IoC 容器中，而其属性 name 定义这个 Bean 的名称，如果没有配置它，则将方法名称“initUser”作为 Bean 的名称保存到 Spring IoC 容器中。</p>\n<p>做好了这些，就可以使用 AnnotationConfigApplicationContext 来构建自己的 IoC 容器，如代码清单 3-4 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.User;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.ApplicationContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.logging.Logger;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IoCTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> Logger.getLogger(IoCTest.class.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> ctx.getBean(User.class);</span><br><span class=\"line\">        log.info(user.getId().toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>代码中将 Java 配置文件 AppConfig 传递给 AnnotationConfigApplicationContext 的构造方法，这样它就能够读取配置了。然后将配置里面的 Bean 装配到 IoC 容器中，于是可以使用 getBean 方法获取对应的 POJO，你可以看到下面的日志打印：</p>\n<p><img src=\"/images/W0ntjjclR0cRfx9d2qlynjZFvQ1yu8nfw6qDzTiIKMY.png\" alt=\"image\"></p>\n<p>显然，配置在配置文件中的名称为 user 的 Bean 已经被装配到 IoC 容器中，并且可以通过getBean 方法获取对应的 Bean，并建 Bean 的属性信息输出出来。当然这只是很简单的方法，而注解 @Bean 也不是唯一创建 Bean 的方法，还有其他的方法可以让 IoC 容器装配 Bean，而且 Bean 之间还有依赖的关系需要进一步处理。这是本章后面章节的主要内容了。</p>\n<h2 id=\"3-2-装配你的-Bean\"><a href=\"#3-2-装配你的-Bean\" class=\"headerlink\" title=\"3.2 装配你的 Bean\"></a>3.2 装配你的 Bean</h2><p>在 Spring 中允许我们通过 XML 或者 Java 配置文件装配 Bean，但是由于 Spring Boot 是基于注解的方式，因此下面主要基于注解的方式来介绍 Spring 的用啊，以满足 Spring Boot 开发者的需要。</p>\n<h3 id=\"3-2-1-通过扫描装配你的-Bean\"><a href=\"#3-2-1-通过扫描装配你的-Bean\" class=\"headerlink\" title=\"3.2.1 通过扫描装配你的 Bean\"></a>3.2.1 通过扫描装配你的 Bean</h3><p>如果一个个的 Bean 使用注解 @Bean 注入 Spring IoC 容器中，那将是一件很麻烦的事情。好在 Spring 还允许我们进行扫描装配 Bean 到 IoC 容器中，对于扫描装配而言使用的注解是 @Component 和 @ComponentScan。@Component 是标明哪个类被扫描进入 Spring IoC 容器，而 @ComponentScan 则是标明采用何种策略去扫描装配到 Bean。</p>\n<p>这里我们首先把代码清单 3-2 中的 User.java 移到包 com.springboot.chapter3.config 内，然后对其进行修改，如代码清单 3-5 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.Data;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component(&quot;user&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;1&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;user_name_1&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;note_1&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String note;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// setter and getter</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里的注解 @Component 表明这个类将被 Spring IoC 容器扫描装配，其中配置的“user”则是作为 Bean 的名称，当然你也可以不配置这个字符串，那么 IoC 容器就会把类名第一个字母作为小写，其他不变作为 Bean 名称放入到 IoC 容器中；注解 @Value 则是指定具体的值，使得 Spring IoC 给于对应的属性注入对应的值。为了让 Spring IoC 容器装配这个类，需要改造类 AppConfig，如代码清单 3-6 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里加入了 @ComponentScan，意味着它会进行扫描，但是它只会扫描类 AppConfig 所在的当前包和其子包，之前把 User.java 移到包 com.springboot.chapter3.config 就是这样原因。这样就可以删掉之前使用 @Bean 标注的创建对象方法。然后进行测试，测试代码如代码清单 3-7 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.ApplicationContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.logging.Logger;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IoCTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> Logger.getLogger(IoCTest.class.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> ctx.getBean(User.class);</span><br><span class=\"line\">        log.info(user.getId().toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这样就能够运行了。然而为了使得 User类能够被扫描，上面我们把它迁移到了本不该放置它的配置包，这样显然就不太合理了。为了更加合理，@ComponentScan 还允许我们自定义扫描的包。下面探讨它的配置项。</p>\n<p>首先探讨 @ComponentScan 的源码，如代码清单 3-8 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.context.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Documented;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Repeatable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"comment\">// 在一个类中可重复定义</span></span><br><span class=\"line\"><span class=\"meta\">@Repeatable(ComponentScans.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> ComponentScan &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义扫描的包</span></span><br><span class=\"line\">    <span class=\"meta\">@AliasFor(&quot;basePackages&quot;)</span></span><br><span class=\"line\">    String[] value() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义扫描的包</span></span><br><span class=\"line\">    <span class=\"meta\">@AliasFor(&quot;value&quot;)</span></span><br><span class=\"line\">    String[] basePackages() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义扫描的类</span></span><br><span class=\"line\">    Class&lt;?&gt;[] basePackageClasses() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Bean name 生成器</span></span><br><span class=\"line\">    Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">BeanNameGenerator</span>&gt; nameGenerator() <span class=\"keyword\">default</span> BeanNameGenerator.class;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 作用域解析器</span></span><br><span class=\"line\">    Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">ScopeMetadataResolver</span>&gt; scopeResolver() <span class=\"keyword\">default</span> AnnotationScopeMetadataResolver.class;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 作用域代理模式</span></span><br><span class=\"line\">    ScopedProxyMode <span class=\"title function_\">scopedProxy</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> ScopedProxyMode.DEFAULT;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 资源匹配模式</span></span><br><span class=\"line\">    String <span class=\"title function_\">resourcePattern</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 是否启用默认的过滤器</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">useDefaultFilters</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当满足过滤器的条件时扫描</span></span><br><span class=\"line\">    Filter[] includeFilters() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当不满足过滤器的条件时扫描</span></span><br><span class=\"line\">    Filter[] excludeFilters() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 是否延迟初始化</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">lazyInit</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义过滤器</span></span><br><span class=\"line\">    <span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\">    <span class=\"meta\">@Target(&#123;&#125;)</span></span><br><span class=\"line\">    <span class=\"meta\">@interface</span> Filter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 过滤器类型，可以按注解类型或者正则式等过滤</span></span><br><span class=\"line\">        FilterType <span class=\"title function_\">type</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> FilterType.ANNOTATION;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 定义过滤的类</span></span><br><span class=\"line\">        <span class=\"meta\">@AliasFor(&quot;classes&quot;)</span></span><br><span class=\"line\">        Class&lt;?&gt;[] value() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 定义过滤的类</span></span><br><span class=\"line\">        <span class=\"meta\">@AliasFor(&quot;value&quot;)</span></span><br><span class=\"line\">        Class&lt;?&gt;[] classes() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 匹配方式</span></span><br><span class=\"line\">        String[] pattern() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面加粗的代码是最常用的配置项，需要了解它们的使用方法。首先可以通过配置项 basePackages 定义扫描的包名，在没有定义的情况下，它只会扫描当前包和其子包下的路径；还可以通过 basePackageClasses 定义扫描的类；其中还有 includeFilters 和 excludeFilters，includeFilters 是定义满足过滤器（Filter）条件的 Bean 才去扫描，excludeFilters 则是排除过滤器条件的 Bean，它们都需要通过一个注解 @Filter 去定义，它有一个type 类型，这里可以定义为注解或者正则式等类型。classes 定义注解类，pattern 定义正则式类。</p>\n<p>此时我们再把 User 类放到包 com.springboot.chapter3.pojo 中，这样 User 和 AppConfig 就不再同包，那么我们把 AppConfig 中的注解修改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(&quot;com.springboot.chapter3.*&quot;)</span></span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &#123;&quot;com.springboot.chapter3.pojo&quot;&#125;)</span></span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackageClasses = &#123;User.class&#125;)</span></span><br></pre></td></tr></table></figure>\n<p>无论采用何种方式都能够使得 IoC 容器去扫描 User 类，而包名可以采用正则去匹配。但是有时候我们的需求是想扫描一些包，将一些 Bean 装配到 Spring IoC 容器中，而不是想加载这个包里面的某些 Bean。比方说，现在我们有一个 UserService 类，为了标注它为服务类，将类标注 @Service（该标准注入了 @Component，所以在默认的情况下它会被 Spring 扫描装配到 IoC 容器中），这里再假设我们采用了策略：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(&quot;com.springboot.chapter3.*&quot;)</span></span><br></pre></td></tr></table></figure>\n<p>这样对于 com.springboot.chapter3.service 和 com.springboot.chapter3.pojo，这两个包都会被扫描，此时我们定义 UserService 类如代码清单 3-9 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.User;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printUser</span><span class=\"params\">(User user)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;编号：&quot;</span> + user.getId());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;用户名称：&quot;</span> + user.getUserName());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;备注：&quot;</span> + user.getNote());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>按以上的装配策略，它将会被扫描到 Spring IoC 容器中。为了不被装配，需要把扫描的策略修改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(value = &quot;com.springboot.chapter3.*&quot;, excludeFilters = &#123;@ComponentScan.Filter(classes = &#123;Provider.Service.class&#125;)&#125;)</span></span><br></pre></td></tr></table></figure>\n<p>这样，由于加入了 excludeFilters 的配置，使标注了@Service 的类将不被 IoC 容器扫描注入，这样就可以把 UserService 类排除到 Spring IoC 容器中了。事实上，之前在 Spring Boot 上述实例中看到的注解@SpringBootApplication 也注入了@ComponentScan，这里不妨探索其源码，如代码清单 3-10 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.boot.autoconfigure;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Documented;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.ElementType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Inherited;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Retention;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(java.lang.annotation.RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span></span><br><span class=\"line\"><span class=\"comment\">// 自定义排除的扫描类</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(excludeFilters = &#123;</span></span><br><span class=\"line\"><span class=\"meta\">        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class=\"line\"><span class=\"meta\">        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SpringBootApplication &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过类型排除自动配置类</span></span><br><span class=\"line\">    <span class=\"meta\">@AliasFor(annotation = EnableAutoConfiguration.class, attribute = &quot;exclude&quot;)</span></span><br><span class=\"line\">    Class&lt;?&gt;[] exclude() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过名称排除自动配置类</span></span><br><span class=\"line\">    <span class=\"meta\">@AliasFor(annotation = EnableAutoConfiguration.class, attribute = &quot;excludeName&quot;)</span></span><br><span class=\"line\">    String[] excludeName() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义扫描的包</span></span><br><span class=\"line\">    <span class=\"meta\">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)</span></span><br><span class=\"line\">    String[] scanBasePackages() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义扫描的类</span></span><br><span class=\"line\">    <span class=\"meta\">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;)</span></span><br><span class=\"line\">    Class&lt;?&gt;[] scanBasePackageClasses() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显然，通过它就能够定义扫描哪些包。但是这里需要特别注意的是，它提供的 exclude 和 excludeName 两个方法是对于其内部的自动配置类才会生效的。为了能够排除其他类，还可以再加入@ComponentScan以达到我们的目的。例如，扫描 User 而不扫描 UserService，可以把启动配置文件写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackage = &#123;&quot;com.springboot.chapter3&quot;&#125;,excludeFilters = &#123;@Filter&#123;classes = Service.class&#125;)</span></span><br></pre></td></tr></table></figure>\n<p>这样就能扫描指定对应的包并排除对应的类了。</p>\n<h3 id=\"3-2-2-自定义第三方-Bean\"><a href=\"#3-2-2-自定义第三方-Bean\" class=\"headerlink\" title=\"3.2.2 自定义第三方 Bean\"></a>3.2.2 自定义第三方 Bean</h3><p>现实的 Java 的应用往往需要引入许多来自第三方的包，并且很有可能希望把第三方包的类对象也放入到 Spring IoC 容器中，这时@Bean 注解就可以发挥作用了。</p>\n<p>例如，要引入一个 DBCP 数据源，我们先在 pom.xml上加入项目所需要 DBCP 包和数据库 MySQL 驱动程序的依赖，如代码清单 3-11 所示。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.springboot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>chapter3<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>chapter3<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>chapter3<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>8<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>6.0.10<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.projectlombok<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>lombok<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.18.26<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.commons<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>commons-dbcp2<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.9.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>8.0.33<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这样 DBCP 和数据库驱动就被加入到了项目中，接着将使用它提供的机制来生成数据源。这时候，可以把代码清单 3-12 中的代码放置到 AppConfig.java 中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.dbcp2.BasicDataSourceFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.sql.DataSource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.Provider;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Properties;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(value = &quot;com.springboot.chapter3.*&quot;, excludeFilters = &#123;@ComponentScan.Filter(classes = &#123;Provider.Service.class&#125;)&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;dataSource&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> DataSource <span class=\"title function_\">getDataSource</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Properties</span> <span class=\"variable\">props</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">        props.setProperty(<span class=\"string\">&quot;driver&quot;</span>, <span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class=\"line\">        props.setProperty(<span class=\"string\">&quot;url&quot;</span>, <span class=\"string\">&quot;jdbc:mysql://localhost:3306/chapter3&quot;</span>);</span><br><span class=\"line\">        props.setProperty(<span class=\"string\">&quot;username&quot;</span>, <span class=\"string\">&quot;root&quot;</span>);</span><br><span class=\"line\">        props.setProperty(<span class=\"string\">&quot;password&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">DataSource</span> <span class=\"variable\">dataSource</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            dataSource = BasicDataSourceFactory.createDataSource(props);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里通过 @Bean 定义了其配置项 name 为“dataSource”，那么 Spring 就会把它返回的对象用名称“dataSource”保存到 IoC 容器中。当然，你也可以不填写这个名称，那么它就会用你的方法名称作为 Bean 名称保存到 IoC 容器中。通过这样，就可以将第三方包的类装配到 Spring IoC 容器中了。</p>\n<h2 id=\"3-3-依赖注入\"><a href=\"#3-3-依赖注入\" class=\"headerlink\" title=\"3.3 依赖注入\"></a>3.3 依赖注入</h2><p>本章的开始讲述了 Spring IoC 的两个作用，上一节只讨论了如何将 Bean 装配到 IoC 容器中，对于如何进行获取，还有一个作用没有谈及，那就是 Bean 之间的依赖，在 Spring IoC 的概念中，我们称为依赖注入（Dependency Injection，DI）。</p>\n<p>例如，人类（Person）有时候利用一些动物（Animal）去完成一些事情，比方说狗（Dog）是用来看门的，猫（Cat）是用来抓老鼠的，鹦鹉（Parrot）是用来迎客的……于是做一些事情就依赖于那些可爱的动物了，如图 3-2 所示。</p>\n<p>为了更好地展示这个过程，首先来定义两个接口，一个是人类（Person），另一个是动物（Animal）。人类是通过动物去提供一些特殊服务的，如代码清单 3-13 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.pojo.definition;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用动物服务</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">service</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置动物</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">setAnimal</span><span class=\"params\">(Animal animal)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.pojo.definition;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">use</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们就拥有了两个接口。接下来我们需要两个实现类，如代码亲的那 3-14 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.pojo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.definition.Animal;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.definition.Person;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BusinessPerson</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Animal</span> <span class=\"variable\">animal</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">service</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.animal.use();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAnimal</span><span class=\"params\">(Animal animal)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.animal = animal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.pojo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.definition.Animal;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">use</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;狗【&quot;</span> + Dog.class.getSimpleName() + <span class=\"string\">&quot;】是看门用的。&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里应注意加粗的注解 @Autowired，这也是我们在 Spring 中最常用的注解之一，十分重要，它会根据属性的类型（by type）找到对应的 Bean 进行注入。这里的 Dog 类是动物的一种，所以 Spring IoC 容器会把 Dog 的实例注入 BusinessPerson 中。这样通过 Spring IoC 容器获取 BusinessPerson 实例的时候就能够使用 Dog 实例来提供服务了，下面是测试的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.config;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.BusinessPerson;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.definition.Person;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.ApplicationContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.logging.Logger;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IoCTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> Logger.getLogger(IoCTest.class.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> ctx.getBean(BusinessPerson.class);</span><br><span class=\"line\">        person.service();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试一下，就可以得到下面的日志：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">狗【Dog】是看门用的。</span><br></pre></td></tr></table></figure>\n<p>显然，测试是成功的，这个时候 Spring IoC 容器已经通过注解 @Autowired 成功地将 Dog 注入到了 BusinessPerson 实例中。但是这只是一个比较简单的例子，我们有必要继续探讨 @Autowired。</p>\n<h3 id=\"3-3-1-注解-Autowired\"><a href=\"#3-3-1-注解-Autowired\" class=\"headerlink\" title=\"3.3.1 注解@Autowired\"></a>3.3.1 注解@Autowired</h3><p>@Autowired 是我们使用得最多的注解之一，因此在这里需要进一步地探讨它。它注入的机制最基本的一条是根据类型（by type），我们回顾 IoC 容器的顶级接口 BeanFactory，就可以知道 IoC 容器是通过 getBean 方法获取对应 Bean 的，而 getBean 又支持根据类型（by type）或者根据名称（by name）。在回到上面的例子，我们只是创建了一个动物——狗，而实际上动物还可以有猫（Cat），猫可以为我们捉老鼠，于是我们又创建了一个猫的类，如代码清单 3-15 所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.pojo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.definition.Animal;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">use</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;猫【&quot;</span> + Cat.class.getSimpleName() + <span class=\"string\">&quot;】是抓老鼠。&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>好了，如果我们还使用着代码清单 3-14 中的 BusinessPerson 类，那么麻烦来了，因为这个类只是定义了一个动物属性（Animal），而我们却有两个动物，一个狗，一个猫，Spring IoC 如何注入呢？如果你还进行测试，很快你就可以看到 IoC 容器抛出异常，如下面的日志所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class=\"string\">&#x27;businessPerson&#x27;</span>: Unsatisfied dependency expressed through field <span class=\"string\">&#x27;animal&#x27;</span>: No qualifying bean of <span class=\"built_in\">type</span> <span class=\"string\">&#x27;com.springboot.chapter3.pojo.definition.Animal&#x27;</span> available: expected single matching bean but found 2: <span class=\"built_in\">cat</span>,dog</span><br></pre></td></tr></table></figure>\n<p>从加粗的日志可以看出，Spring IoC 容器并不能知道你需要注入什么动物（是狗？是猫？）给 BusinessPerson 类对象，从而引起错误的发生。那么使用@Autowired 能处理这个问题吗？答案是肯定的。假设我们目前需要的是狗提供服务，那么可以把属性名称转化为 dog，也就是原来的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">Animal</span> <span class=\"variable\">animal</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>修改为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">Animal</span> <span class=\"variable\">dog</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>这里，我们只是将属性的名称从 animal 修改为了 dog，那么我们再测试的时候，你可以看到是采用狗来提供服务的。那是因为 @Autowired 提供这样的规则，首先它会根据类型找到对应的 Bean，如果对应类型的 Bean 不是唯一的，那么它会根据其属性名称和 Bean 的名称进行匹配。如果匹配得上，就会使用该 Bean；如果还无法匹配，就会抛出异常。</p>\n<p>这里还要注意的是 @Autowired 是一个默认必须找到对应 Bean 的注解，如果不能确定其标注属性一定会存在并且允许这个被标注的属性为 null，那么你可以配置 @Autowired 属性 required 为 false，例如，像下面一样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired(required = false)</span></span><br></pre></td></tr></table></figure>\n<p>同样，它除了可以标注属性外，还可以标注方法，如 setAnimal 方法，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAnimal</span> <span class=\"params\">(Animal animal)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.animal = animal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样它也会使用 setAnimal 方法从 IoC 容器中找到对应的动物进行注入，甚至我们还可以使用在方法参数上，后面会再谈到它。</p>\n<h3 id=\"3-3-2-消除歧义性——-Primary-和-Quelifier\"><a href=\"#3-3-2-消除歧义性——-Primary-和-Quelifier\" class=\"headerlink\" title=\"3.3.2 消除歧义性——@Primary 和 @Quelifier\"></a>3.3.2 消除歧义性——@Primary 和 @Quelifier</h3><p>在上面我们发现有猫有狗的时候，为了使@Autowired 能够继续使用，我们做了一个决定，将 BusinessPerson 的属性名称从 animal 修改为 dog。显然这是一个憋屈的做法，好好的一个动物，却被我们定义为了狗。产生注入失败的问题根本是按类型（by type）查找，正如动物可以有多种类型，这样会造成 Spring IoC 容器注入的困扰，我们把这样的一个问题称为歧义性。知道这个原因后，那么这两个注解是从哪个角度去解决这些问题的呢？这是本节要解决的问题。</p>\n<p>首先是一个注解 @Primary，它是一个修改优先权的注解，当我们有猫有狗的时候，假设这次需要使用猫，那么只需要在猫类的定义上加入@Primary 就可以了，类似下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.springboot.chapter3.pojo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.springboot.chapter3.pojo.definition.Animal;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Primary;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Primary</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">use</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;猫【&quot;</span> + Cat.class.getSimpleName() + <span class=\"string\">&quot;】是抓老鼠。&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的 @Primary 的含义告诉 Spring IoC 容器，当发现有多个同样类型的 Bean 时，请优先使用我进行注入，于是再进行测试时会发现，系统将用猫 为你提供服务。因为当 Spring 进行注入的时候，虽然它发现存在多个动物，但因为 Cat 被标注为了 @Primary，所以优先采用 Cat 的实例进行了注入，这样就通过优先级的变换使得 IoC 容器知道注入哪个具体的实例来满足依赖注入。</p>\n<h3 id=\"3-3-3-带有参数的构造方法类的装配\"><a href=\"#3-3-3-带有参数的构造方法类的装配\" class=\"headerlink\" title=\"3.3.3 带有参数的构造方法类的装配\"></a>3.3.3 带有参数的构造方法类的装配</h3><h2 id=\"3-4-生命周期\"><a href=\"#3-4-生命周期\" class=\"headerlink\" title=\"3.4 生命周期\"></a>3.4 生命周期</h2><h2 id=\"3-5-使用属性文件\"><a href=\"#3-5-使用属性文件\" class=\"headerlink\" title=\"3.5 使用属性文件\"></a>3.5 使用属性文件</h2><h2 id=\"3-6-条件装配-Bean\"><a href=\"#3-6-条件装配-Bean\" class=\"headerlink\" title=\"3.6 条件装配 Bean\"></a>3.6 条件装配 Bean</h2><h2 id=\"3-7-Bean-的作用域\"><a href=\"#3-7-Bean-的作用域\" class=\"headerlink\" title=\"3.7 Bean 的作用域\"></a>3.7 Bean 的作用域</h2><h2 id=\"3-8-使用-Profile\"><a href=\"#3-8-使用-Profile\" class=\"headerlink\" title=\"3.8 使用@Profile\"></a>3.8 使用@Profile</h2><h2 id=\"3-9-引入-XML-配置-Bean\"><a href=\"#3-9-引入-XML-配置-Bean\" class=\"headerlink\" title=\"3.9 引入 XML 配置 Bean\"></a>3.9 引入 XML 配置 Bean</h2><h2 id=\"3-10-使用-Spring-EL\"><a href=\"#3-10-使用-Spring-EL\" class=\"headerlink\" title=\"3.10 使用 Spring EL\"></a>3.10 使用 Spring EL</h2>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clrl0f7pa0000hkuy5695g6is","tag_id":"clrl0f7pd0001hkuy53bf4k28","_id":"clrl0f7pf0002hkuy2an09use"}],"Tag":[{"name":"spring, ioc, spring ioc, spring bean, spring bean definition, spring bean factory, spring bean container, spring bean post processor, spring bean pre processor, spring bean definition reader, spring bean definition parser, spring bean definition registry, spring bean definition factory, spring bean definition factory bean, spring bean definition factory bean post processor, spring bean definition factory bean pre processor, spring bean definition factory bean parser, spring bean definition factory bean registry, spring bean definition factory bean factory","_id":"clrl0f7pd0001hkuy53bf4k28"}]}}